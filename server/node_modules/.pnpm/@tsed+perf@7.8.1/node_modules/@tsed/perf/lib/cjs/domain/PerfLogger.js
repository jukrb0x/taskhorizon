"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerfLogger = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const Perf_1 = require("./Perf");
const loggers = new Map();
// istanbul ignore next
class PerfLogger {
    label;
    levels;
    #perf = new Perf_1.Perf();
    #enabled = false;
    constructor(label = "perf", levels = { 10: "green", 50: "yellow", 100: "red" }) {
        this.label = label;
        this.levels = levels;
        this.wrap = this.wrap.bind(this);
        this.log = this.log.bind(this);
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.bind = this.bind.bind(this);
    }
    static get(label) {
        if (loggers.get(label)) {
            return loggers.get(label);
        }
        const logger = loggers.get(label) || new PerfLogger(label);
        loggers.set(label, logger);
        return logger;
    }
    start() {
        this.#enabled = true;
        this.#perf.start();
        return this;
    }
    log(...args) {
        if (this.#enabled) {
            console.debug(this.formatLog(["LOG   -", ...args], this.#perf.fromLatest(), "from latest: "));
        }
        return this;
    }
    bind(instance) {
        const methods = (0, core_1.methodsOf)((0, core_1.classOf)(instance));
        const { wrap, log } = this;
        methods.forEach(({ target, propertyKey }) => {
            const descriptor = (0, core_1.descriptorOf)(target, propertyKey);
            const name = (0, core_1.nameOf)(target);
            if (descriptor.value) {
                const fn = instance[propertyKey].bind(instance);
                if (propertyKey === "log") {
                    instance[propertyKey] = (...args) => {
                        log(...args);
                        return fn(...args);
                    };
                }
                else {
                    instance[propertyKey] = (...args) => {
                        return wrap(() => fn(...args), `${name}.${propertyKey}()`);
                    };
                }
            }
        });
        return instance;
    }
    wrap(fn, name = (0, core_1.nameOf)(fn)) {
        if (!this.#enabled) {
            return fn();
        }
        console.debug(this.formatLog([`START - ${name}`], this.#perf.fromLatest(), "from latest: "));
        return this.#perf.run(fn, (time) => {
            if (this.#enabled) {
                console.debug(this.formatLog([`END   - ${name}`], time, "method: "));
            }
        });
    }
    end() {
        if (this.#enabled) {
            console.debug(this.formatLog(["ending"], this.#perf.end(), "from start: "));
            this.#enabled = false;
        }
        return this;
    }
    formatLog(log, diff, wrap = "") {
        const dataLog = log.join(" ") + "                                                                                    ";
        const diffLabel = this.formatDiff(diff, wrap);
        const fromStart = this.#perf.fromStart();
        const globalDiff = ("     " + fromStart.toFixed(3) + "ms").slice(-10);
        return `[${this.label}] ${globalDiff} - ${String(dataLog)}`.slice(0, 80) + ` ${diffLabel}`;
    }
    formatDiff(diff, prefix = "") {
        const label = `(${prefix}+${diff}ms)`;
        const list = Object.entries(this.levels);
        const [, color] = list.find(([level]) => diff <= +level) || list[list.length - 1];
        return chalk_1.default[color](label);
    }
}
exports.PerfLogger = PerfLogger;
//# sourceMappingURL=PerfLogger.js.map