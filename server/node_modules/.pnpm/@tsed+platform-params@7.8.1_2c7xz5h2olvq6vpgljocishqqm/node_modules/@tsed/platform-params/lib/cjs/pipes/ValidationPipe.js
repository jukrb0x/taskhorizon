"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationPipe = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const schema_1 = require("@tsed/schema");
const RequiredValidationError_1 = require("../errors/RequiredValidationError");
const ParamTypes_1 = require("../domain/ParamTypes");
function cast(value, metadata) {
    try {
        return (0, json_mapper_1.deserialize)(value, {
            type: metadata.type
        });
    }
    catch (er) {
        return value;
    }
}
let ValidationPipe = class ValidationPipe {
    validator;
    constructor(injector) {
        const provider = injector.getProviders().find((provider) => (0, core_1.nameOf)(provider.token) === "AjvService");
        if (provider) {
            this.validator = injector.invoke(provider.token);
        }
    }
    coerceTypes(value, metadata) {
        if (value === undefined) {
            return value;
        }
        if (value === "null") {
            return null;
        }
        if (metadata.isArray) {
            return [].concat(value);
        }
        if (metadata.isPrimitive) {
            return cast(value, metadata);
        }
        return value;
    }
    skip(value, metadata) {
        return metadata.paramType === ParamTypes_1.ParamTypes.PATH && !metadata.isPrimitive;
    }
    async transform(value, metadata) {
        if (!this.validator) {
            this.checkIsRequired(value, metadata);
            return value;
        }
        if (this.skip(value, metadata)) {
            return value;
        }
        value = this.coerceTypes(value, metadata);
        this.checkIsRequired(value, metadata);
        if (value === undefined) {
            return value;
        }
        const schema = (0, schema_1.getJsonSchema)(metadata, {
            customKeys: true
        });
        await this.validator.validate(value, {
            schema,
            type: metadata.isClass ? metadata.type : undefined,
            collectionType: metadata.collectionType
        });
        return value;
    }
    checkIsRequired(value, metadata) {
        if (metadata.isRequired(value)) {
            throw RequiredValidationError_1.RequiredValidationError.from(metadata);
        }
        return true;
    }
};
ValidationPipe = tslib_1.__decorate([
    (0, di_1.Injectable)({
        type: "validator"
    }),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], ValidationPipe);
exports.ValidationPipe = ValidationPipe;
//# sourceMappingURL=ValidationPipe.js.map