{"version":3,"file":"ProviderOpts.js","sourceRoot":"","sources":["../../../src/interfaces/ProviderOpts.ts"],"names":[],"mappings":"","sourcesContent":["import type {Type} from \"@tsed/core\";\nimport type {ProviderType} from \"../domain/ProviderType\";\nimport type {DIResolver} from \"./DIResolver\";\nimport type {ProviderScope} from \"../domain/ProviderScope\";\nimport type {TokenProvider} from \"./TokenProvider\";\n\nexport interface ProviderOpts<T = any> {\n  /**\n   * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n   */\n  provide: TokenProvider;\n  /**\n   * Provider type\n   */\n  type?: TokenProvider | ProviderType;\n  /**\n   * Instance build by the injector\n   */\n  instance?: T;\n  /**\n   * Define dependencies to build the provider\n   */\n  deps?: TokenProvider[];\n  /**\n   * Class to instantiate for the `token`.\n   */\n  useClass?: Type<T>;\n  /**\n   * Provide a function to build the provider\n   */\n  useFactory?: Function;\n  /**\n   * Provide an async function to build the provider\n   */\n  useAsyncFactory?: Function;\n  /**\n   * Provide predefined value\n   */\n  useValue?: any;\n  /**\n   * Scope used by the injector to build the provider.\n   */\n  scope?: ProviderScope;\n  /**\n   * A list of resolvers which will be used to resolve missing Symbol/Class when injector invoke a Class. This property allow external DI usage.\n   */\n  resolvers?: DIResolver[];\n\n  /**\n   * hooks to intercept custom events\n   */\n  hooks?: Record<string, (instance: T, ...args: any[]) => Promise<any> | any>;\n  /**\n   *\n   */\n  [key: string]: any;\n}\n"]}