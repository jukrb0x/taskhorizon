{"version":3,"file":"lazyInject.js","sourceRoot":"","sources":["../../../src/decorators/lazyInject.ts"],"names":[],"mappings":";;;AAAA,qCAAyC;AACzC,qCAAwC;AAExC;;;;;;;;;;;;;;;;;;;GAmBG;AACH,SAAgB,UAAU,CACxB,GAAW,EACX,QAAmB,EACnB,EAAC,QAAQ,GAAG,KAAK,EAAE,WAAW,GAAG,QAAQ,CAAC,QAAQ,EAAE,KAAgD,EAAE;IAEtG,OAAO,CAAC,MAAW,EAAE,WAAmB,EAAc,EAAE;QACtD,IAAI,IAAS,EAAE,KAAU,CAAC;QAC1B,IAAA,uBAAc,EAAC,MAAM,EAAE,WAAW,EAAE;YAClC,QAAQ,CAAC,QAAQ;gBACf,OAAO,KAAK,IAAI,EAAE;oBAChB,IAAI,CAAC,KAAK,EAAE;wBACV,MAAM,OAAO,GAAG,MAAM,IAAA,oBAAa,EAAC,WAAW,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;wBACrE,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;wBAErB,IAAI,CAAC,KAAK,EAAE;4BACV,IAAI,CAAC,QAAQ,EAAE;gCACb,MAAM,IAAI,KAAK,CAAC,4BAA4B,GAAG,6CAA6C,CAAC,CAAC;6BAC/F;yBACF;wBAED,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,MAAM,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;qBACtD;oBAED,OAAO,IAAI,CAAC;gBACd,CAAC,CAAC;YACJ,CAAC;SACF,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AA5BD,gCA4BC;AAED;;;;;;;;;;;;;;;;;GAiBG;AACH,SAAgB,kBAAkB,CAAC,GAAW,EAAE,QAAmB;IACjE,OAAQ,UAAkB,CAAC,GAAG,EAAE,QAAQ,EAAE,EAAC,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;AAC9D,CAAC;AAFD,gDAEC","sourcesContent":["import {importPackage} from \"@tsed/core\";\nimport {injectProperty} from \"./inject\";\n\n/**\n * Lazy load a provider from his package and invoke only when the provider is used\n *\n * ```typescript\n * import type {PlatformException} from \"@tsed/platform-exceptions\";\n *\n * @Injectable()\n * export class MyService {\n *   @LazyInject(\"PlatformException\", () => import(\"@tsed/platform-exceptions\"))\n *   exceptions: Promise<PlatformException>;\n * }\n * ```\n *\n * @param key\n * @param packageName\n * @param resolver\n * @param optional\n * @returns {Function}\n * @decorator\n */\nexport function LazyInject(\n  key: string,\n  resolver: () => any,\n  {optional = false, packageName = resolver.toString()}: {optional?: boolean; packageName?: string} = {}\n): PropertyDecorator {\n  return (target: any, propertyKey: string): any | void => {\n    let bean: any, token: any;\n    injectProperty(target, propertyKey, {\n      resolver(injector) {\n        return async () => {\n          if (!token) {\n            const exports = await importPackage(packageName, resolver, optional);\n            token = exports[key];\n\n            if (!token) {\n              if (!optional) {\n                throw new Error(`Unable to lazy load the \"${key}\". The token isn\\'t a valid token provider.`);\n              }\n            }\n\n            bean = token ? await injector.lazyInvoke(token) : {};\n          }\n\n          return bean;\n        };\n      }\n    });\n  };\n}\n\n/**\n * Optionally Lazy load a provider from his package and invoke only when the provider is used\n *\n * ```typescript\n * import type {PlatformException} from \"@tsed/platform-exceptions\";\n *\n * @Injectable()\n * export class MyService {\n *   @OptionalLazyInject(\"@tsed/platform-exceptions\")\n *   exceptions: Promise<PlatformException>;\n * }\n * ```\n *\n * @param key\n * @param resolver\n * @returns {Function}\n * @decorator\n */\nexport function OptionalLazyInject(key: string, resolver: () => any): PropertyDecorator {\n  return (LazyInject as any)(key, resolver, {optional: true});\n}\n"]}