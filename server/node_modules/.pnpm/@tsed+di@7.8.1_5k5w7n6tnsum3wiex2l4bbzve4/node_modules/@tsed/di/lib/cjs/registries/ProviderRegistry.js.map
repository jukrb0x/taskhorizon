{"version":3,"file":"ProviderRegistry.js","sourceRoot":"","sources":["../../../src/registries/ProviderRegistry.ts"],"names":[],"mappings":";;;AAAA,iDAA4C;AAC5C,2DAAsD;AACtD,yDAAoD;AAEpD,uDAAkD;AAElD;;GAEG;AACH,iCAAe,CAAC,cAAc,CAAC,2BAAY,CAAC,UAAU,EAAE,mBAAQ,CAAC,CAAC;AAElE;;;GAGG;AACH,SAAgB,gBAAgB,CAAa,QAAqC;IAChF,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;QACrB,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;KACjD;IAED,OAAO,iCAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AAC3D,CAAC;AAND,4CAMC;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACI,MAAM,aAAa,GAAG,CAAC,QAAiC,EAAE,KAAW,EAAQ,EAAE;IACpF,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;QACrB,QAAQ,GAAG;YACT,OAAO,EAAE,QAAQ;SAClB,CAAC;KACH;IAED,QAAQ,GAAG,MAAM,CAAC,MAAM,CACtB;QACE,KAAK,EAAE,6BAAa,CAAC,SAAS;QAC9B,QAAQ,EAAE,KAAK;KAChB,EACD,QAAQ,EACR,EAAC,IAAI,EAAE,2BAAY,CAAC,KAAK,EAAC,CAC3B,CAAC;IACF,iCAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AACpD,CAAC,CAAC;AAhBW,QAAA,aAAa,iBAgBxB;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACU,QAAA,kBAAkB,GAAG,iCAAe,CAAC,gBAAgB,CAAC,2BAAY,CAAC,UAAU,CAAC,CAAC","sourcesContent":["import {Provider} from \"../domain/Provider\";\nimport {ProviderScope} from \"../domain/ProviderScope\";\nimport {ProviderType} from \"../domain/ProviderType\";\nimport type {ProviderOpts} from \"../interfaces/ProviderOpts\";\nimport {GlobalProviders} from \"./GlobalProviders\";\n\n/**\n *\n */\nGlobalProviders.createRegistry(ProviderType.CONTROLLER, Provider);\n\n/**\n * Register a provider configuration.\n * @param {ProviderOpts<any>} provider\n */\nexport function registerProvider<Type = any>(provider: Partial<ProviderOpts<Type>>) {\n  if (!provider.provide) {\n    throw new Error(\"Provider.provide is required\");\n  }\n\n  return GlobalProviders.merge(provider.provide, provider);\n}\n\n/**\n * Add a new value in the `ProviderRegistry`.\n *\n * #### Example with symbol definition\n *\n *\n * ```typescript\n * import {registerValue, InjectorService} from \"@tsed/di\";\n *\n * const MyValue = Symbol.from(\"MyValue\")\n *\n * registerValue({token: MyValue, useValue: \"myValue\"});\n *\n * @Service()\n * export class OtherService {\n *      constructor(@Inject(MyValue) myValue: string){\n *          console.log(myValue); /// \"myValue\"\n *      }\n * }\n * ```\n */\nexport const registerValue = (provider: any | ProviderOpts<any>, value?: any): void => {\n  if (!provider.provide) {\n    provider = {\n      provide: provider\n    };\n  }\n\n  provider = Object.assign(\n    {\n      scope: ProviderScope.SINGLETON,\n      useValue: value\n    },\n    provider,\n    {type: ProviderType.VALUE}\n  );\n  GlobalProviders.merge(provider.provide, provider);\n};\n\n/**\n * Add a new controller in the `ProviderRegistry`. This controller will be built when `InjectorService` will be loaded.\n *\n * #### Example\n *\n * ```typescript\n * import {registerController, InjectorService} from \"@tsed/di\";\n *\n * export default class MyController {\n *     constructor(){}\n *     transform() {\n *         return \"test\";\n *     }\n * }\n *\n * registerController({provide: MyController});\n * // or\n * registerController(MyController);\n *\n * const injector = new InjectorService();\n * injector.load();\n *\n * const myController = injector.get<MyController>(MyController);\n * myController.getFoo(); // test\n * ```\n *\n * @param provider Provider configuration.\n */\nexport const registerController = GlobalProviders.createRegisterFn(ProviderType.CONTROLLER);\n"]}