"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InjectContext = exports.Inject = exports.injectProperty = void 0;
const core_1 = require("@tsed/core");
const constants_1 = require("../constants/constants");
const InvalidPropertyTokenError_1 = require("../errors/InvalidPropertyTokenError");
const asyncHookContext_1 = require("../utils/asyncHookContext");
function injectProperty(target, propertyKey, options) {
    core_1.Store.from(target).merge(constants_1.INJECTABLE_PROP, {
        [propertyKey]: {
            bindingType: core_1.DecoratorTypes.PROP,
            propertyKey,
            ...options
        }
    });
}
exports.injectProperty = injectProperty;
/**
 * Inject a provider to another provider.
 *
 * Use this decorator to inject a custom provider on constructor parameter or property.
 *
 * ```typescript
 * @Injectable()
 * export class MyService {
 *   @Inject(CONNECTION)
 *   connection: CONNECTION;
 * }
 * ```
 *
 * @param token A token provider or token provider group
 * @param onGet Use the given name method to inject
 * @returns {Function}
 * @decorator
 */
function Inject(token, onGet = (bean) => bean) {
    return (target, propertyKey, descriptor) => {
        const bindingType = (0, core_1.decoratorTypeOf)([target, propertyKey, descriptor]);
        switch (bindingType) {
            case core_1.DecoratorTypes.PARAM_CTOR:
                if (token) {
                    const paramTypes = core_1.Metadata.getParamTypes(target, propertyKey);
                    const type = paramTypes[descriptor];
                    paramTypes[descriptor] = type === Array ? [token] : token;
                    core_1.Metadata.setParamTypes(target, propertyKey, paramTypes);
                }
                break;
            case core_1.DecoratorTypes.PROP:
                const useType = token || core_1.Metadata.getType(target, propertyKey);
                const originalType = core_1.Metadata.getType(target, propertyKey);
                if (useType === Object) {
                    throw new InvalidPropertyTokenError_1.InvalidPropertyTokenError(target, propertyKey);
                }
                injectProperty(target, propertyKey, {
                    resolver(injector, locals, { options, ...invokeOptions }) {
                        const originalType = core_1.Metadata.getType(target, propertyKey);
                        locals.set(constants_1.DI_PARAM_OPTIONS, { ...options });
                        if (originalType === Array) {
                            let bean;
                            if (!bean) {
                                bean = injector.getMany(token, locals, invokeOptions);
                                locals.delete(constants_1.DI_PARAM_OPTIONS);
                            }
                            bean.forEach((instance, index) => {
                                if ((0, core_1.isPromise)(bean)) {
                                    instance.then((result) => {
                                        bean[index] = result;
                                    });
                                }
                            });
                            return () => onGet(bean);
                        }
                        let bean;
                        if (!bean) {
                            bean = injector.invoke(useType, locals, invokeOptions);
                            locals.delete(constants_1.DI_PARAM_OPTIONS);
                        }
                        if ((0, core_1.isPromise)(bean)) {
                            bean.then((result) => {
                                bean = result;
                            });
                        }
                        return () => onGet(bean);
                    }
                });
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);
        }
    };
}
exports.Inject = Inject;
/**
 * Inject a context like PlatformContext or any BaseContext.
 *
 * ```typescript
 * @Injectable()
 * export class MyService {
 *   @InjectContext()
 *   ctx?: Context;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 */
function InjectContext() {
    return (target, propertyKey) => {
        injectProperty(target, propertyKey, {
            resolver() {
                return () => (0, asyncHookContext_1.getContext)();
            }
        });
    };
}
exports.InjectContext = InjectContext;
//# sourceMappingURL=inject.js.map