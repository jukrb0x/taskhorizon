{"version":3,"file":"GlobalProviders.js","sourceRoot":"","sources":["../../../src/registries/GlobalProviders.ts"],"names":[],"mappings":"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","sourcesContent":["import {getClassOrSymbol, Type} from \"@tsed/core\";\nimport type {LocalsContainer} from \"../domain/LocalsContainer\";\nimport {Provider} from \"../domain/Provider\";\nimport {ProviderType} from \"../domain/ProviderType\";\nimport {ProviderOpts} from \"../interfaces/ProviderOpts\";\nimport {RegistrySettings} from \"../interfaces/RegistrySettings\";\nimport {ResolvedInvokeOptions} from \"../interfaces/ResolvedInvokeOptions\";\nimport {TokenProvider} from \"../interfaces/TokenProvider\";\nimport type {InjectorService} from \"../services/InjectorService\";\n\nexport class GlobalProviderRegistry extends Map<TokenProvider, Provider> {\n  #settings: Map<string, RegistrySettings> = new Map();\n\n  /**\n   * The get() method returns a specified element from a Map object.\n   * @param key Required. The key of the element to return from the Map object.\n   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.\n   */\n  get(key: TokenProvider): Provider | undefined {\n    return super.get(getClassOrSymbol(key));\n  }\n\n  /**\n   * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key\n   * @returns {boolean}\n   */\n  has(key: TokenProvider): boolean {\n    return super.has(getClassOrSymbol(key));\n  }\n\n  /**\n   * The set() method adds or updates an element with a specified key and value to a Map object.\n   * @param key Required. The key of the element to add to the Map object.\n   * @param metadata Required. The value of the element to add to the Map object.\n   */\n  set(key: TokenProvider, metadata: Provider): this {\n    super.set(getClassOrSymbol(key), metadata);\n\n    return this;\n  }\n\n  /**\n   *\n   * @param target\n   * @param options\n   */\n  merge(target: TokenProvider, options: Partial<ProviderOpts>) {\n    const meta = this.createIfNotExists(target, options);\n\n    Object.keys(options).forEach((key) => {\n      meta[key] = (options as any)[key];\n    });\n\n    this.set(target, meta);\n\n    return meta;\n  }\n\n  /**\n   * The delete() method removes the specified element from a Map object.\n   * @param key Required. The key of the element to remove from the Map object.\n   * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.\n   */\n  delete(key: TokenProvider): boolean {\n    return super.delete(getClassOrSymbol(key));\n  }\n\n  createRegistry(type: string, model: Type<Provider>, options: Partial<RegistrySettings> = {}) {\n    const defaultOptions = this.getRegistrySettings(type);\n\n    options = Object.assign(defaultOptions, {\n      ...options,\n      model\n    });\n\n    this.#settings.set(type, options);\n\n    return this;\n  }\n\n  onInvoke(provider: Provider, locals: LocalsContainer, options: ResolvedInvokeOptions & {injector: InjectorService}) {\n    const settings = this.#settings.get(provider.type);\n\n    if (settings?.onInvoke) {\n      settings.onInvoke(provider, locals, options);\n    }\n  }\n\n  getRegistrySettings(target: string | TokenProvider): RegistrySettings {\n    let type: string = \"provider\";\n\n    if (typeof target === \"string\") {\n      type = target;\n    } else {\n      const provider = this.get(target);\n      if (provider) {\n        type = provider.type;\n      }\n    }\n\n    return (\n      this.#settings.get(type) || {\n        model: Provider\n      }\n    );\n  }\n\n  createRegisterFn(type: string) {\n    return (provider: any | ProviderOpts, instance?: any): void => {\n      // istanbul ignore next\n      if (!provider.provide) {\n        provider = {\n          provide: provider\n        };\n      }\n\n      provider = Object.assign({instance}, provider, {type});\n      this.merge(provider.provide, provider);\n    };\n  }\n\n  /**\n   *\n   * @param key\n   * @param options\n   */\n  protected createIfNotExists(key: TokenProvider, options: Partial<ProviderOpts>): Provider {\n    const type = options.type || ProviderType.PROVIDER;\n\n    if (!this.has(key)) {\n      const {model = Provider} = this.#settings.get(type) || {};\n\n      const item = new model(key, options);\n\n      this.set(key, item);\n    }\n\n    return this.get(key)!;\n  }\n}\n\n/**\n *\n * @type {GlobalProviders}\n */\n// tslint:disable-next-line: variable-name\nexport const GlobalProviders = new GlobalProviderRegistry();\n"]}