{"version":3,"file":"inject.js","sourceRoot":"","sources":["../../../src/decorators/inject.ts"],"names":[],"mappings":"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","sourcesContent":["import {decoratorTypeOf, DecoratorTypes, isPromise, Metadata, Store, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {DI_PARAM_OPTIONS, INJECTABLE_PROP} from \"../constants/constants\";\nimport {InvalidPropertyTokenError} from \"../errors/InvalidPropertyTokenError\";\nimport type {InjectablePropertyOptions} from \"../interfaces/InjectableProperties\";\nimport {TokenProvider} from \"../interfaces/TokenProvider\";\nimport {getContext} from \"../utils/asyncHookContext\";\n\nexport function injectProperty(target: any, propertyKey: string, options: Partial<InjectablePropertyOptions>) {\n  Store.from(target).merge(INJECTABLE_PROP, {\n    [propertyKey]: {\n      bindingType: DecoratorTypes.PROP,\n      propertyKey,\n      ...options\n    }\n  });\n}\n\n/**\n * Inject a provider to another provider.\n *\n * Use this decorator to inject a custom provider on constructor parameter or property.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @Inject(CONNECTION)\n *   connection: CONNECTION;\n * }\n * ```\n *\n * @param token A token provider or token provider group\n * @param onGet Use the given name method to inject\n * @returns {Function}\n * @decorator\n */\nexport function Inject(token?: TokenProvider | (() => TokenProvider), onGet = (bean: any) => bean): Function {\n  return (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<Function> | number): any | void => {\n    const bindingType = decoratorTypeOf([target, propertyKey, descriptor]);\n\n    switch (bindingType) {\n      case DecoratorTypes.PARAM_CTOR:\n        if (token) {\n          const paramTypes = Metadata.getParamTypes(target, propertyKey);\n          const type = paramTypes[descriptor as number];\n\n          paramTypes[descriptor as number] = type === Array ? [token] : token;\n\n          Metadata.setParamTypes(target, propertyKey, paramTypes);\n        }\n        break;\n\n      case DecoratorTypes.PROP:\n        const useType = token || Metadata.getType(target, propertyKey);\n        const originalType = Metadata.getType(target, propertyKey);\n\n        if (useType === Object) {\n          throw new InvalidPropertyTokenError(target, propertyKey);\n        }\n\n        injectProperty(target, propertyKey, {\n          resolver(injector, locals, {options, ...invokeOptions}) {\n            const originalType = Metadata.getType(target, propertyKey);\n            locals.set(DI_PARAM_OPTIONS, {...options});\n\n            if (originalType === Array) {\n              let bean: any[] | undefined;\n\n              if (!bean) {\n                bean = injector.getMany(token, locals, invokeOptions);\n                locals.delete(DI_PARAM_OPTIONS);\n              }\n\n              bean.forEach((instance: any, index) => {\n                if (isPromise(bean)) {\n                  instance.then((result: any) => {\n                    bean![index] = result;\n                  });\n                }\n              });\n\n              return () => onGet(bean);\n            }\n\n            let bean: any;\n\n            if (!bean) {\n              bean = injector.invoke(useType, locals, invokeOptions);\n              locals.delete(DI_PARAM_OPTIONS);\n            }\n\n            if (isPromise(bean)) {\n              bean.then((result: any) => {\n                bean = result;\n              });\n            }\n\n            return () => onGet(bean);\n          }\n        });\n        break;\n\n      default:\n        throw new UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);\n    }\n  };\n}\n\n/**\n * Inject a context like PlatformContext or any BaseContext.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @InjectContext()\n *   ctx?: Context;\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n */\nexport function InjectContext(): PropertyDecorator {\n  return (target: any, propertyKey: string): any | void => {\n    injectProperty(target, propertyKey, {\n      resolver() {\n        return () => getContext();\n      }\n    });\n  };\n}\n"]}