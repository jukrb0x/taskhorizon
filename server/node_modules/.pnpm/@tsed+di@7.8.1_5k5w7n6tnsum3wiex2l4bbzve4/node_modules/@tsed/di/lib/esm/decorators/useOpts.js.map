{"version":3,"file":"useOpts.js","sourceRoot":"","sources":["../../../src/decorators/useOpts.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,eAAe,EAAE,cAAc,EAAE,KAAK,EAAE,wBAAwB,EAAC,MAAM,YAAY,CAAC;AAC5F,OAAO,EAAC,gBAAgB,EAAE,eAAe,EAAC,MAAM,wBAAwB,CAAC;AAEzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCG;AACH,MAAM,UAAU,OAAO,CAAC,OAA6B;IACnD,OAAO,CAAC,MAAc,EAAE,WAA4B,EAAE,KAAc,EAAO,EAAE;QAC3E,MAAM,WAAW,GAAG,eAAe,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;QAElE,QAAQ,WAAW,EAAE;YACnB,KAAK,cAAc,CAAC,UAAU;gBAC5B,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,GAAG,gBAAgB,IAAI,KAAK,EAAE,EAAE,OAAO,CAAC,CAAC;gBAClE,MAAM;YAER,KAAK,cAAc,CAAC,IAAI;gBACtB,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,eAAe,EAAE;oBACxC,CAAC,WAAqB,CAAC,EAAE;wBACvB,OAAO;qBACR;iBACF,CAAC,CAAC;gBACH,MAAM;YAER;gBACE,MAAM,IAAI,wBAAwB,CAAC,OAAO,EAAE,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;SAC7E;IACH,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import {decoratorTypeOf, DecoratorTypes, Store, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {DI_PARAM_OPTIONS, INJECTABLE_PROP} from \"../constants/constants\";\n\n/**\n * Add options to invoke the Service.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @returns {Function}\n * @decorator\n * @param options\n */\nexport function UseOpts(options: {[key: string]: any}): Function {\n  return (target: Object, propertyKey: string | symbol, index?: number): any => {\n    const bindingType = decoratorTypeOf([target, propertyKey, index]);\n\n    switch (bindingType) {\n      case DecoratorTypes.PARAM_CTOR:\n        Store.from(target).merge(`${DI_PARAM_OPTIONS}:${index}`, options);\n        break;\n\n      case DecoratorTypes.PROP:\n        Store.from(target).merge(INJECTABLE_PROP, {\n          [propertyKey as string]: {\n            options\n          }\n        });\n        break;\n\n      default:\n        throw new UnsupportedDecoratorType(UseOpts, [target, propertyKey, index]);\n    }\n  };\n}\n"]}