"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformHandler = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const logger_1 = require("@tsed/logger");
const platform_exceptions_1 = require("@tsed/platform-exceptions");
const platform_params_1 = require("@tsed/platform-params");
const platform_response_filter_1 = require("@tsed/platform-response-filter");
const platform_router_1 = require("@tsed/platform-router");
const util_1 = require("util");
const AnyToPromiseWithCtx_1 = require("../domain/AnyToPromiseWithCtx");
const setResponseHeaders_1 = require("../utils/setResponseHeaders");
const PlatformApplication_1 = require("./PlatformApplication");
const PlatformMiddlewaresChain_1 = require("./PlatformMiddlewaresChain");
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */
let PlatformHandler = class PlatformHandler {
    platformRouters;
    responseFilter;
    platformParams;
    platformExceptions;
    platformApplication;
    platformMiddlewaresChain;
    constructor(platformRouters) {
        this.platformRouters = platformRouters;
        // configure the router module
        platformRouters.hooks
            .on("alterEndpointHandlers", (allMiddlewares, operationRoute) => {
            allMiddlewares = this.platformMiddlewaresChain.get(allMiddlewares, operationRoute);
            return [...allMiddlewares, (0, platform_router_1.useResponseHandler)(this.onFinish.bind(this))];
        })
            .on("alterHandler", (handlerMetadata) => {
            return this.platformApplication.adapter.mapHandler(this.createHandler(handlerMetadata), handlerMetadata);
        });
    }
    createHandler(handlerMetadata) {
        if (handlerMetadata.isInjectable()) {
            const handler = this.platformParams.compileHandler(handlerMetadata);
            return async ($ctx) => {
                $ctx.handlerMetadata = handlerMetadata;
                await (0, core_1.catchAsyncError)(() => this.onRequest(handler, $ctx));
                return this.next($ctx);
            };
        }
        return handlerMetadata.handler;
    }
    /**
     * @param provider
     * @param propertyKey
     */
    createCustomHandler(provider, propertyKey) {
        const metadata = new platform_router_1.PlatformHandlerMetadata({
            provider,
            type: platform_router_1.PlatformHandlerType.CUSTOM,
            propertyKey
        });
        const handler = this.platformParams.compileHandler(metadata.store);
        return async ($ctx) => {
            $ctx.handlerMetadata = metadata;
            // @ts-ignore
            return this.onRequest(handler, $ctx);
        };
    }
    /**
     * Send the response to the consumer.
     * @protected
     * @param $ctx
     */
    async flush($ctx) {
        const { response } = $ctx;
        if (!$ctx.isDone()) {
            let data = await this.responseFilter.serialize($ctx.data, $ctx);
            data = await this.responseFilter.transform(data, $ctx);
            response.body(data);
        }
    }
    /**
     * @param $ctx
     */
    next($ctx) {
        if ((0, core_1.isStream)($ctx.data) || $ctx.isDone()) {
            return;
        }
        return $ctx.error ? $ctx.next($ctx.error) : $ctx.next();
    }
    /**
     * Call handler when a request his handle
     */
    async onRequest(handler, $ctx) {
        if ($ctx.isDone()) {
            logger_1.$log.error({
                name: "HEADERS_SENT",
                message: `An endpoint is called but the response is already send to the client. The call comes from the handler: ${$ctx.handlerMetadata.toString()}`
            });
            return;
        }
        if (($ctx.error instanceof Error && !$ctx.handlerMetadata.hasErrorParam) || ($ctx.handlerMetadata.hasErrorParam && !$ctx.error)) {
            return;
        }
        try {
            const { handlerMetadata } = $ctx;
            if (handlerMetadata.type === platform_router_1.PlatformHandlerType.CTX_FN) {
                return await handler({ $ctx });
            }
            const resolver = new AnyToPromiseWithCtx_1.AnyToPromiseWithCtx($ctx);
            const { state, type, data, status, headers } = await resolver.call(handler);
            // Note: restore previous handler metadata (for OIDC)
            $ctx.handlerMetadata = handlerMetadata;
            if (state === core_1.AnyToPromiseStatus.RESOLVED) {
                if (status) {
                    $ctx.response.status(status);
                }
                if (headers) {
                    $ctx.response.setHeaders(headers);
                }
                if (data !== undefined) {
                    $ctx.data = data;
                }
                if (!$ctx.isDone()) {
                    $ctx.error = null;
                    // set headers each times that an endpoint is called
                    if (handlerMetadata.isEndpoint()) {
                        (0, setResponseHeaders_1.setResponseHeaders)($ctx);
                    }
                    // call returned middleware
                    if ((0, core_1.isFunction)($ctx.data) && !(0, core_1.isStream)($ctx.data)) {
                        return (0, util_1.promisify)($ctx.data)($ctx.getRequest(), $ctx.getResponse());
                    }
                    if (type === core_1.AnyToPromiseResponseTypes.STREAM) {
                        return this.flush($ctx);
                    }
                }
            }
        }
        catch (error) {
            $ctx.error = error;
            throw error;
        }
    }
    async onFinish($ctx) {
        $ctx.error = await (0, core_1.catchAsyncError)(() => this.flush($ctx));
        return $ctx.error && this.platformExceptions.catch($ctx.error, $ctx);
    }
};
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", platform_response_filter_1.PlatformResponseFilter)
], PlatformHandler.prototype, "responseFilter", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", platform_params_1.PlatformParams)
], PlatformHandler.prototype, "platformParams", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", platform_exceptions_1.PlatformExceptions)
], PlatformHandler.prototype, "platformExceptions", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", PlatformApplication_1.PlatformApplication)
], PlatformHandler.prototype, "platformApplication", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", PlatformMiddlewaresChain_1.PlatformMiddlewaresChain)
], PlatformHandler.prototype, "platformMiddlewaresChain", void 0);
PlatformHandler = tslib_1.__decorate([
    (0, di_1.Injectable)({
        scope: di_1.ProviderScope.SINGLETON
    }),
    tslib_1.__metadata("design:paramtypes", [platform_router_1.PlatformRouters])
], PlatformHandler);
exports.PlatformHandler = PlatformHandler;
//# sourceMappingURL=PlatformHandler.js.map