import { isFunction, isString, nameOf } from "@tsed/core";
import { colors, setLoggerConfiguration } from "@tsed/di";
import { getMiddlewaresForHook } from "@tsed/platform-middlewares";
import { Platform } from "../services/Platform.js";
import { PlatformAdapter } from "../services/PlatformAdapter.js";
import { PlatformApplication } from "../services/PlatformApplication.js";
import { createHttpServer } from "../utils/createHttpServer.js";
import { createHttpsServer } from "../utils/createHttpsServer.js";
import { createInjector } from "../utils/createInjector.js";
import { getConfiguration } from "../utils/getConfiguration.js";
import { getStaticsOptions } from "../utils/getStaticsOptions.js";
import { printRoutes } from "../utils/printRoutes.js";
/**
 * @platform
 */
export class PlatformBuilder {
    static adapter;
    name = "";
    startedAt = new Date();
    current = new Date();
    #injector;
    #rootModule;
    #adapter;
    #promise;
    #servers;
    #listeners = [];
    constructor(adapter, module, settings) {
        this.#rootModule = module;
        const configuration = getConfiguration(settings, module);
        const adapterKlass = adapter || PlatformBuilder.adapter;
        const name = nameOf(adapterKlass).replace("Platform", "").toLowerCase();
        configuration.PLATFORM_NAME = name;
        this.name = name;
        this.#injector = createInjector({
            adapter: adapterKlass,
            settings: configuration
        });
        this.#adapter = this.#injector.get(PlatformAdapter);
        this.createHttpServers();
        this.#adapter.onInit && this.#adapter.onInit();
        this.log("Injector created...");
    }
    get injector() {
        return this.#injector;
    }
    get rootModule() {
        return this.#injector.get(this.#rootModule);
    }
    get app() {
        return this.injector.get(PlatformApplication);
    }
    get platform() {
        return this.injector.get(Platform);
    }
    get adapter() {
        return this.#adapter;
    }
    /**
     * Return the settings configured by the decorator @@Configuration@@.
     *
     * ```typescript
     * @Configuration({
     *    rootDir: Path.resolve(__dirname),
     *    port: 8000,
     *    httpsPort: 8080,
     *    mount: {
     *      "/rest": "${rootDir}/controllers/**\/*.js"
     *    }
     * })
     * export class Server {
     *     $onInit(){
     *         console.log(this.settings); // {rootDir, port, httpsPort,...}
     *     }
     * }
     * ```
     *
     * @returns {PlatformConfiguration}
     */
    get settings() {
        return this.injector.settings;
    }
    get logger() {
        return this.injector.logger;
    }
    get disableBootstrapLog() {
        return this.settings.get("logger.disableBootstrapLog");
    }
    static create(module, settings) {
        return this.build(module, {
            httpsPort: false,
            httpPort: false,
            ...settings
        });
    }
    static build(module, { adapter, ...settings }) {
        return new PlatformBuilder(adapter, module, settings);
    }
    /**
     * Bootstrap a server application
     * @param module
     * @param settings
     */
    static async bootstrap(module, settings) {
        return this.build(module, settings).bootstrap();
    }
    callback(req, res) {
        if (req && res) {
            return this.callback()(req, res);
        }
        return this.app.callback();
    }
    log(...data) {
        return !this.disableBootstrapLog && this.logger.info(...data, this.diff());
    }
    /**
     * Add classes to the components list
     * @param classes
     */
    addComponents(classes) {
        this.settings.set("imports", this.settings.get("imports", []).concat(classes));
        return this;
    }
    /**
     * Add classes decorated by @@Controller@@ to components container.
     *
     * ### Example
     *
     * ```typescript
     * @Controller('/ctrl')
     * class MyController{
     * }
     *
     * platform.addControllers('/rest', [MyController])
     * ```
     *
     * ::: tip
     * If the MyController class isn't decorated, the class will be ignored.
     * :::
     *
     * @param {string} endpoint
     * @param {any[]} controllers
     */
    addControllers(endpoint, controllers) {
        [].concat(controllers).forEach((token) => {
            this.settings.routes.push({ token, route: endpoint });
        });
    }
    async runLifecycle() {
        setLoggerConfiguration(this.injector);
        await this.mapTokenMiddlewares();
        await this.loadInjector();
        this.#adapter.useContext();
        await this.loadRoutes();
        return this;
    }
    async loadInjector() {
        const { injector } = this;
        this.log("Build providers");
        await injector.loadModule(this.#rootModule);
        this.log("Settings and injector loaded...");
        await this.callHook("$afterInit");
    }
    async listen(network = true) {
        if (!this.#promise) {
            await this.bootstrap();
        }
        await this.callHook("$beforeListen");
        if (network) {
            await this.listenServers();
        }
        await this.callHook("$afterListen");
        await this.ready();
    }
    async stop() {
        await this.callHook("$onDestroy");
        await this.injector.destroy();
        this.#listeners.map((server) => {
            return new Promise((resolve) => server.close(() => resolve(undefined)));
        });
    }
    async ready() {
        const { startedAt } = this;
        await this.callHook("$onReady");
        await this.injector.emit("$onServerReady");
        this.log(`Started in ${new Date().getTime() - startedAt.getTime()} ms`);
    }
    async callHook(hook, ...args) {
        const { injector } = this;
        if (!this.disableBootstrapLog) {
            injector.logger.debug(`\x1B[1mCall hook ${hook}\x1B[22m`);
        }
        // Load middlewares for the given hook
        this.loadMiddlewaresFor(hook);
        // call hooks added by providers
        await injector.emit(hook, ...args);
    }
    async loadStatics(hook) {
        const statics = this.settings.get("statics");
        getStaticsOptions(statics).forEach(({ path, options }) => {
            if (options.hook === hook) {
                this.platform.app.statics(path, options);
            }
        });
    }
    useProvider(token, settings) {
        this.injector.addProvider(token, settings);
        return this;
    }
    async bootstrap() {
        this.#promise = this.#promise || this.runLifecycle();
        return this.#promise;
    }
    async loadRoutes() {
        this.#adapter.beforeLoadRoutes && (await this.#adapter.beforeLoadRoutes());
        // istanbul ignore next
        if (this.settings.get("logger.level") !== "off") {
            const { PlatformLogMiddleware } = await import("@tsed/platform-log-middleware");
            this.app.use(PlatformLogMiddleware);
        }
        this.log("Load routes");
        if (this.rootModule.$beforeRoutesInit) {
            await this.rootModule.$beforeRoutesInit();
            this.rootModule.$beforeRoutesInit = () => { };
        }
        await this.loadStatics("$beforeRoutesInit");
        await this.callHook("$beforeRoutesInit");
        const routes = this.injector.settings.get("routes");
        this.platform.addRoutes(routes);
        await this.callHook("$onRoutesInit");
        await this.loadStatics("$afterRoutesInit");
        await this.callHook("$afterRoutesInit");
        this.#adapter.afterLoadRoutes && (await this.#adapter.afterLoadRoutes());
        await this.mapRouters();
    }
    async mapRouters() {
        const layers = this.platform.getLayers();
        this.#adapter.mapLayers(layers);
        const rawBody = this.settings.get("rawBody") ||
            layers.some(({ handlers }) => {
                return handlers.some((handler) => handler.opts?.paramsTypes?.RAW_BODY);
            });
        this.settings.set("rawBody", rawBody);
        return this.logRoutes(layers.filter((layer) => layer.isProvider()));
    }
    diff() {
        const ms = colors.yellow(`+${new Date().getTime() - this.current.getTime()}ms`);
        this.current = new Date();
        return ms;
    }
    /**
     * Load middlewares from configuration for the given hook
     * @param hook
     * @protected
     */
    loadMiddlewaresFor(hook) {
        return getMiddlewaresForHook(hook, this.settings, "$beforeRoutesInit").forEach(({ use }) => {
            this.app.use(use);
        });
    }
    createHttpServers() {
        this.#servers = [createHttpServer(this.#injector, this.callback()), createHttpsServer(this.#injector, this.callback())].filter(Boolean);
    }
    async listenServers() {
        this.#listeners = await Promise.all(this.#servers.map((cb) => cb && cb()));
    }
    async logRoutes(layers) {
        const { logger } = this;
        this.log("Routes mounted...");
        if (!this.settings.get("logger.disableRoutesSummary") && !this.disableBootstrapLog) {
            const routes = layers.map((layer) => {
                return {
                    url: layer.path,
                    method: layer.method,
                    name: layer.opts.name || `${layer.provider.className}.constructor()`,
                    className: layer.opts.className || layer.provider.className,
                    methodClassName: layer.opts.methodClassName || ""
                };
            });
            logger.info(printRoutes(await this.injector.alterAsync("$logRoutes", routes)));
        }
    }
    async mapTokenMiddlewares() {
        let middlewares = this.injector.settings.get("middlewares", []);
        const { env } = this.injector.settings;
        const defaultHook = "$beforeRoutesInit";
        const promises = middlewares.map(async (middleware) => {
            if (isFunction(middleware)) {
                return {
                    env,
                    hook: defaultHook,
                    use: middleware
                };
            }
            if (isString(middleware)) {
                middleware = { env, use: middleware, hook: defaultHook };
            }
            let { use, options } = middleware;
            if (isString(use)) {
                if (["text-parser", "raw-parser", "json-parser", "urlencoded-parser"].includes(use)) {
                    use = this.adapter.bodyParser(use.replace("-parser", ""), options);
                }
                else {
                    const mod = await import(use);
                    use = (mod.default || mod)(options);
                }
            }
            return {
                env,
                hook: defaultHook,
                ...middleware,
                use
            };
        });
        middlewares = await Promise.all(promises);
        this.injector.settings.set("middlewares", middlewares);
    }
}
//# sourceMappingURL=PlatformBuilder.js.map