"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AjvService = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const schema_1 = require("@tsed/schema");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const AjvValidationError_1 = require("../errors/AjvValidationError");
const defaultErrorFormatter_1 = require("../utils/defaultErrorFormatter");
require("./Ajv");
const getPath_1 = require("../utils/getPath");
let AjvService = class AjvService {
    errorFormatter;
    ajv;
    async validate(value, options) {
        let { schema: defaultSchema, type, collectionType, ...additionalOptions } = this.mapOptions(options);
        const schema = defaultSchema || (0, schema_1.getJsonSchema)(type, { ...additionalOptions, customKeys: true });
        if (schema) {
            const localValue = (0, core_1.deepClone)(value);
            const validate = this.ajv.compile(schema);
            const valid = await validate(localValue);
            const { errors } = validate;
            if (!valid && errors) {
                throw this.mapErrors(errors, {
                    type,
                    collectionType,
                    async: true,
                    value: localValue
                });
            }
        }
        return value;
    }
    mapOptions(options) {
        if (options instanceof schema_1.JsonSchema) {
            return {
                schema: options.toJSON({ customKeys: true })
            };
        }
        return options;
    }
    mapErrors(errors, options) {
        const { type, collectionType, value } = options;
        const message = errors
            .map((error) => {
            if (collectionType) {
                error.collectionName = (0, core_1.nameOf)(collectionType);
            }
            const dataPath = (0, getPath_1.getPath)(error);
            if (!error.data) {
                if (dataPath) {
                    error.data = (0, core_1.getValue)(value, dataPath.replace(/^\./, ""));
                }
                else if (error.schemaPath !== "#/required") {
                    error.data = value;
                }
            }
            if (dataPath && dataPath.match(/pwd|password|mdp|secret/)) {
                error.data = "[REDACTED]";
            }
            if (type) {
                error.modelName = (0, core_1.nameOf)(type);
                error.message = this.mapClassError(error, type);
            }
            return this.errorFormatter.call(this, error, {});
        })
            .join("\n");
        return new AjvValidationError_1.AjvValidationError(message, errors);
    }
    mapClassError(error, targetType) {
        const propertyKey = (0, core_1.getValue)(error, "params.missingProperty");
        if (propertyKey) {
            const store = schema_1.JsonEntityStore.from((0, core_1.prototypeOf)(targetType), propertyKey);
            if (store) {
                (0, core_1.setValue)(error, "params.missingProperty", store.name || propertyKey);
                return error.message.replace(`'${propertyKey}'`, `'${store.name || propertyKey}'`);
            }
        }
        return error.message;
    }
};
tslib_1.__decorate([
    (0, di_1.Constant)("ajv.errorFormatter", defaultErrorFormatter_1.defaultErrorFormatter),
    tslib_1.__metadata("design:type", Function)
], AjvService.prototype, "errorFormatter", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", ajv_1.default)
], AjvService.prototype, "ajv", void 0);
AjvService = tslib_1.__decorate([
    (0, di_1.Injectable)()
], AjvService);
exports.AjvService = AjvService;
//# sourceMappingURL=AjvService.js.map