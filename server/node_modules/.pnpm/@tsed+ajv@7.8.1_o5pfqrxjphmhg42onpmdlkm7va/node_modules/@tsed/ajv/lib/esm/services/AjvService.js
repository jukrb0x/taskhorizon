import { __decorate, __metadata } from "tslib";
import { deepClone, getValue, nameOf, prototypeOf, setValue } from "@tsed/core";
import { Constant, Inject, Injectable } from "@tsed/di";
import { getJsonSchema, JsonEntityStore, JsonSchema } from "@tsed/schema";
import Ajv from "ajv";
import { AjvValidationError } from "../errors/AjvValidationError.js";
import { defaultErrorFormatter } from "../utils/defaultErrorFormatter.js";
import "./Ajv.js";
import { getPath } from "../utils/getPath.js";
let AjvService = class AjvService {
    errorFormatter;
    ajv;
    async validate(value, options) {
        let { schema: defaultSchema, type, collectionType, ...additionalOptions } = this.mapOptions(options);
        const schema = defaultSchema || getJsonSchema(type, { ...additionalOptions, customKeys: true });
        if (schema) {
            const localValue = deepClone(value);
            const validate = this.ajv.compile(schema);
            const valid = await validate(localValue);
            const { errors } = validate;
            if (!valid && errors) {
                throw this.mapErrors(errors, {
                    type,
                    collectionType,
                    async: true,
                    value: localValue
                });
            }
        }
        return value;
    }
    mapOptions(options) {
        if (options instanceof JsonSchema) {
            return {
                schema: options.toJSON({ customKeys: true })
            };
        }
        return options;
    }
    mapErrors(errors, options) {
        const { type, collectionType, value } = options;
        const message = errors
            .map((error) => {
            if (collectionType) {
                error.collectionName = nameOf(collectionType);
            }
            const dataPath = getPath(error);
            if (!error.data) {
                if (dataPath) {
                    error.data = getValue(value, dataPath.replace(/^\./, ""));
                }
                else if (error.schemaPath !== "#/required") {
                    error.data = value;
                }
            }
            if (dataPath && dataPath.match(/pwd|password|mdp|secret/)) {
                error.data = "[REDACTED]";
            }
            if (type) {
                error.modelName = nameOf(type);
                error.message = this.mapClassError(error, type);
            }
            return this.errorFormatter.call(this, error, {});
        })
            .join("\n");
        return new AjvValidationError(message, errors);
    }
    mapClassError(error, targetType) {
        const propertyKey = getValue(error, "params.missingProperty");
        if (propertyKey) {
            const store = JsonEntityStore.from(prototypeOf(targetType), propertyKey);
            if (store) {
                setValue(error, "params.missingProperty", store.name || propertyKey);
                return error.message.replace(`'${propertyKey}'`, `'${store.name || propertyKey}'`);
            }
        }
        return error.message;
    }
};
__decorate([
    Constant("ajv.errorFormatter", defaultErrorFormatter),
    __metadata("design:type", Function)
], AjvService.prototype, "errorFormatter", void 0);
__decorate([
    Inject(),
    __metadata("design:type", Ajv)
], AjvService.prototype, "ajv", void 0);
AjvService = __decorate([
    Injectable()
], AjvService);
export { AjvService };
//# sourceMappingURL=AjvService.js.map