"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCode = void 0;
const ts_morph_1 = require("ts-morph");
const generateEnums_1 = require("./utils/generateEnums");
const generateModels_1 = require("./utils/generateModels");
const generateClientIndex_1 = require("./utils/generateClientIndex");
const generateInterfaces_1 = require("./utils/generateInterfaces");
const generateIndex_1 = require("./utils/generateIndex");
const generatePrismaService_1 = require("./utils/generatePrismaService");
const generateRepositories_1 = require("./utils/generateRepositories");
const saveProject_1 = require("./utils/saveProject");
const baseCompilerOptions = {
    target: ts_morph_1.ScriptTarget.ES2019,
    module: ts_morph_1.ModuleKind.CommonJS,
    emitDecoratorMetadata: true,
    experimentalDecorators: true,
    esModuleInterop: true
};
async function generateCode(dmmf, options) {
    const baseDirPath = options.outputDirPath;
    const emitTranspiledCode = options.emitTranspiledCode ? true : options.outputDirPath.includes("node_modules");
    const project = new ts_morph_1.Project({
        compilerOptions: {
            ...baseCompilerOptions,
            ...(emitTranspiledCode && { declaration: true })
        }
    });
    const hasEnum = (0, generateEnums_1.generateEnums)(dmmf, project, baseDirPath);
    (0, generateModels_1.generateModels)(dmmf, project, baseDirPath);
    (0, generateInterfaces_1.generateInterfaces)(project, baseDirPath);
    (0, generateClientIndex_1.generateClientIndex)(project, baseDirPath, options);
    (0, generatePrismaService_1.generatePrismaService)(project, baseDirPath);
    (0, generateRepositories_1.generateRepositories)(dmmf, project, baseDirPath);
    (0, generateIndex_1.generateIndex)(project, baseDirPath, hasEnum);
    if (emitTranspiledCode) {
        await project.emit();
    }
    else {
        await (0, saveProject_1.saveProject)(project);
    }
}
exports.generateCode = generateCode;
//# sourceMappingURL=generateCode.js.map