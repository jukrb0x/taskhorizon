"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRepositories = void 0;
const tslib_1 = require("tslib");
const ts_morph_1 = require("ts-morph");
const core_1 = require("@tsed/core");
const path_1 = tslib_1.__importDefault(require("path"));
const DmmfModel_1 = require("../domain/DmmfModel");
const generateOutputsBarrelFile_1 = require("./generateOutputsBarrelFile");
const pluralize_1 = tslib_1.__importDefault(require("pluralize"));
const change_case_1 = require("change-case");
function addDelegatedMethod({ name, hasQuestionToken, repository, model, returnType }) {
    const method = repository.addMethod({
        name: name,
        isAsync: true,
        returnType: returnType ? `Promise<${returnType}>` : undefined,
        parameters: [
            {
                name: "args",
                type: `Prisma.${model}${(0, change_case_1.pascalCase)(name)}Args`,
                hasQuestionToken
            }
        ]
    });
    if (returnType) {
        method.setBodyText(`const obj = await this.collection.${name}(args);
        return this.deserialize<${returnType}>(obj);`);
    }
    else {
        method.setBodyText(`return this.collection.${name}(args)`);
    }
}
function generateRepositories(dmmf, project, baseDirPath) {
    const modelsMap = (0, core_1.toMap)(dmmf.datamodel.models, "name");
    const models = DmmfModel_1.DmmfModel.getModels(dmmf, modelsMap);
    const repoDirPath = path_1.default.resolve(baseDirPath, "repositories");
    const repoDirectory = project.createDirectory(repoDirPath);
    const repositoriesIndex = repoDirectory.createSourceFile(`index.ts`, undefined, { overwrite: true });
    const exportedModels = models.map((model) => {
        const name = (0, change_case_1.pascalCase)(`${(0, pluralize_1.default)(model.name)}Repository`);
        const modelName = model.toString();
        const sourceFile = repoDirectory.createSourceFile(`${name}.ts`, undefined, { overwrite: true });
        sourceFile.addImportDeclarations([
            {
                moduleSpecifier: "@tsed/core",
                namedImports: ["isArray"]
            },
            {
                moduleSpecifier: "@tsed/json-mapper",
                namedImports: ["deserialize"]
            },
            {
                moduleSpecifier: "@tsed/di",
                namedImports: ["Injectable", "Inject"]
            },
            {
                moduleSpecifier: "../services/PrismaService",
                namedImports: ["PrismaService"]
            },
            {
                moduleSpecifier: "../client",
                namedImports: ["Prisma", model.name]
            },
            {
                moduleSpecifier: "../models",
                namedImports: [model.toString()]
            }
        ]);
        const repository = sourceFile.addClass({
            name,
            isExported: true,
            decorators: [
                {
                    name: "Injectable",
                    arguments: []
                }
            ]
        });
        repository.addProperty({
            name: "prisma",
            type: "PrismaService",
            scope: ts_morph_1.Scope.Protected,
            decorators: [
                {
                    name: "Inject",
                    arguments: []
                }
            ]
        });
        repository
            .addGetAccessor({
            name: "collection"
        })
            .setBodyText(`return this.prisma.${(0, change_case_1.camelCase)(model.name)}`);
        repository
            .addGetAccessor({
            name: "groupBy"
        })
            .setBodyText(`return this.collection.groupBy.bind(this.collection)`);
        repository
            .addMethod({
            name: "deserialize",
            scope: ts_morph_1.Scope.Protected,
            returnType: "T",
            parameters: [
                {
                    name: "obj",
                    type: `null | ${model.name} | ${model.name}[]`
                }
            ],
            typeParameters: ["T"]
        })
            .setBodyText(`return deserialize<T>(obj, {type: ${modelName}, collectionType: isArray(obj) ? Array : undefined})`);
        addDelegatedMethod({
            repository,
            name: "findUnique",
            model: model.name,
            returnType: `${modelName} | null`
        });
        addDelegatedMethod({
            repository,
            name: "findFirst",
            model: model.name,
            returnType: `${modelName} | null`
        });
        addDelegatedMethod({
            repository,
            name: "findMany",
            model: model.name,
            returnType: `${modelName}[]`,
            hasQuestionToken: true
        });
        addDelegatedMethod({
            repository,
            name: "create",
            model: model.name,
            returnType: `${modelName}`
        });
        addDelegatedMethod({
            repository,
            name: "update",
            model: model.name,
            returnType: `${modelName}`
        });
        addDelegatedMethod({
            repository,
            name: "upsert",
            model: model.name,
            returnType: `${modelName}`
        });
        addDelegatedMethod({
            repository,
            name: "delete",
            model: model.name,
            returnType: `${modelName}`
        });
        addDelegatedMethod({
            repository,
            name: "deleteMany",
            model: model.name
        });
        addDelegatedMethod({
            repository,
            name: "updateMany",
            model: model.name
        });
        addDelegatedMethod({
            repository,
            name: "aggregate",
            model: (0, change_case_1.pascalCase)(model.name)
        });
        return name;
    });
    (0, generateOutputsBarrelFile_1.generateOutputsBarrelFile)(repositoriesIndex, exportedModels);
}
exports.generateRepositories = generateRepositories;
//# sourceMappingURL=generateRepositories.js.map