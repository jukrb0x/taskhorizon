{"version":3,"file":"ProtocolsService.js","sourceRoot":"","sources":["../../../src/services/ProtocolsService.ts"],"names":[],"mappings":";AAAA,OAAO,EAAkB,eAAe,EAAC,MAAM,cAAc,CAAC;AAC9D,OAAO,EAAC,WAAW,EAAC,MAAM,YAAY,CAAC;AACvC,OAAO,EAAC,MAAM,EAAE,UAAU,EAAE,eAAe,EAAW,MAAM,UAAU,CAAC;AACvE,OAAO,EAAC,YAAY,EAAC,MAAM,kBAAkB,CAAC;AAC9C,OAAO,QAAQ,EAAE,EAAC,QAAQ,EAAC,MAAM,UAAU,CAAC;AAC5C,OAAO,EAAC,SAAS,EAAC,MAAM,MAAM,CAAC;AAC/B,OAAO,EAAC,sBAAsB,EAAC,MAAM,uBAAuB,CAAC;AAC7D,OAAO,EAAC,iBAAiB,EAAC,MAAM,6BAA6B,CAAC;AAI9D;;GAEG;AAEH,IAAa,gBAAgB,GAA7B,MAAa,gBAAgB;IAClB,UAAU,GAA0B,IAAI,GAAG,EAAE,CAAC;IAG7C,eAAe,CAAkB;IAGnC,QAAQ,CAAkB;IAE3B,YAAY;QACjB,OAAO,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,sBAAsB,CAAC,CAAC;IAC5D,CAAC;IAEM,iBAAiB;QACtB,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;IAC5C,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,MAAM,CAAC,QAAkB;QAC7B,IAAI,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,EAAC,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QACxE,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAwC,QAAQ,CAAC,OAAO,CAAE,CAAC;QAE7F,IAAI,QAAQ,CAAC,cAAc,EAAE;YAC3B,QAAQ,GAAG,CAAC,MAAM,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ,CAAC;SAClE;QAED,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC;QAEtE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAEpC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAE7B,IAAI,QAAQ,CAAC,UAAU,EAAE;YACvB,MAAM,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;SACrC;QAED,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC;QAE9B,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,YAAY,CAAC,SAA4B,EAAE,OAA4B,EAAE,GAAoB;QACxG,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;IAC5D,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,SAAS,CAAC,SAA4B,EAAE,OAA4B,EAAE,GAAoB;QACrG,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;IACzD,CAAC;IAED;;;;;;;OAOG;IACK,KAAK,CAAC,IAAI,CAChB,MAAoC,EACpC,SAA4B,EAC5B,OAA4B,EAC5B,GAAoB;QAEpB,MAAM,OAAO,GAAG,GAAG,CAAC,UAAU,EAAE,CAAC;QACjC,MAAM,QAAQ,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;QACnC,SAAS,GAAI,EAAe,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAE/C,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YAC1B,MAAM,IAAI,YAAY,CAAC,gBAAgB,CAAC,CAAC;SAC1C;QAED,IAAI;YACF,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC;YAC7B,aAAa;YACb,MAAM,EAAE,GAAG,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;YAEnG,MAAM,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SAC7B;QAAC,OAAO,EAAE,EAAE;YACX,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;gBACpC,MAAM,IAAI,iBAAiB,CAAC,EAAE,CAAC,CAAC;aACjC;YAED,MAAM,EAAE,CAAC;SACV;IACH,CAAC;IAED;;;;OAIG;IACK,UAAU,CAAC,QAAuB;QACxC,MAAM,EAAC,IAAI,EAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAC9C,MAAM,EAAC,WAAW,GAAG,QAAQ,EAAE,QAAQ,GAAG,EAAE,EAAC,GAAoB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,sBAAsB,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;QAEhI,OAAO;YACL,IAAI;YACJ,WAAW;YACX,QAAQ,EAAE;gBACR,GAAG,QAAQ;gBACX,iBAAiB,EAAE,IAAI;aACxB;SACF,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACK,aAAa,CAAC,QAAkB;QACtC,MAAM,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;QAEnF,OAAO,KAAK,EAAE,GAAQ,EAAE,GAAG,IAAW,EAAE,EAAE;YACxC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAEnC,IAAI,GAAG,CAAC,IAAI,EAAE;gBACZ,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,eAAe,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEjD,IAAI;oBACF,MAAM,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBAE3B,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;iBACzC;gBAAC,OAAO,GAAG,EAAE;oBACZ,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,EAAC,OAAO,EAAE,GAAG,CAAC,OAAO,EAAC,CAAC,CAAC;iBAC1C;aACF;iBAAM;gBACL,IAAI,CAAC,IAAI,KAAK,CAAC,sBAAsB,CAAC,EAAE,KAAK,EAAE,EAAC,OAAO,EAAE,sBAAsB,EAAC,CAAC,CAAC;aACnF;QACH,CAAC,CAAC;IACJ,CAAC;CACF,CAAA;AA9IC;IADC,MAAM,EAAE;8BACkB,eAAe;yDAAC;AAG3C;IADC,MAAM,EAAE;8BACS,eAAe;kDAAC;AAPvB,gBAAgB;IAD5B,UAAU,EAAE;GACA,gBAAgB,CAkJ5B;SAlJY,gBAAgB","sourcesContent":["import {PlatformContext, PlatformHandler} from \"@tsed/common\";\nimport {ancestorsOf} from \"@tsed/core\";\nimport {Inject, Injectable, InjectorService, Provider} from \"@tsed/di\";\nimport {Unauthorized} from \"@tsed/exceptions\";\nimport Passport, {Strategy} from \"passport\";\nimport {promisify} from \"util\";\nimport {PROVIDER_TYPE_PROTOCOL} from \"../contants/constants\";\nimport {PassportException} from \"../errors/PassportException\";\nimport type {ProtocolMethods} from \"../interfaces/ProtocolMethods\";\nimport type {ProtocolOptions} from \"../interfaces/ProtocolOptions\";\n\n/**\n * @ignore\n */\n@Injectable()\nexport class ProtocolsService {\n  readonly strategies: Map<string, Strategy> = new Map();\n\n  @Inject()\n  protected platformHandler: PlatformHandler;\n\n  @Inject()\n  private injector: InjectorService;\n\n  public getProtocols(): Provider[] {\n    return this.injector.getProviders(PROVIDER_TYPE_PROTOCOL);\n  }\n\n  public getProtocolsNames(): string[] {\n    return Array.from(this.strategies.keys());\n  }\n\n  /**\n   * Invoke provider and bind it to passport.\n   * @param provider\n   */\n  async invoke(provider: Provider) {\n    let {name, useStrategy: strategy, settings} = this.getOptions(provider);\n    const protocol = this.injector.get<ProtocolMethods & Record<string, any>>(provider.provide)!;\n\n    if (protocol.$beforeInstall) {\n      settings = (await protocol.$beforeInstall(settings)) || settings;\n    }\n\n    const instance = new strategy(settings, this.createHandler(provider));\n\n    this.strategies.set(name, instance);\n\n    Passport.use(name, instance);\n\n    if (protocol.$onInstall) {\n      await protocol.$onInstall(instance);\n    }\n\n    protocol.$strategy = instance;\n\n    return protocol;\n  }\n\n  /**\n   * Call authenticate passport method.\n   * @param protocols\n   * @param options\n   * @param ctx\n   */\n  public async authenticate(protocols: string | string[], options: Record<string, any>, ctx: PlatformContext) {\n    return this.call(\"authenticate\", protocols, options, ctx);\n  }\n\n  /**\n   * Call authorize passport method.\n   * @param protocols\n   * @param options\n   * @param ctx\n   */\n  public async authorize(protocols: string | string[], options: Record<string, any>, ctx: PlatformContext) {\n    return this.call(\"authorize\", protocols, options, ctx);\n  }\n\n  /**\n   * Call passport authenticate or authorize depending on the chosen method.\n   * @param method\n   * @param protocols\n   * @param options\n   * @param ctx\n   * @private\n   */\n  private async call(\n    method: \"authenticate\" | \"authorize\",\n    protocols: string | string[],\n    options: Record<string, any>,\n    ctx: PlatformContext\n  ) {\n    const request = ctx.getRequest();\n    const response = ctx.getResponse();\n    protocols = ([] as string[]).concat(protocols);\n\n    if (protocols.length === 0) {\n      throw new Unauthorized(\"Not authorized\");\n    }\n\n    try {\n      options.failWithError = true;\n      // @ts-ignore\n      const fn = promisify(Passport[method](protocols.length === 1 ? protocols[0] : protocols, options));\n\n      await fn(request, response);\n    } catch (er) {\n      if (!ancestorsOf(er).includes(Error)) {\n        throw new PassportException(er);\n      }\n\n      throw er;\n    }\n  }\n\n  /**\n   * Create strategy options based on decorator metadata and global configuration\n   * @param provider\n   * @private\n   */\n  private getOptions(provider: Provider<any>): ProtocolOptions {\n    const {name} = provider.store.get(\"protocol\");\n    const {useStrategy = Strategy, settings = {}}: ProtocolOptions = this.injector.settings.get(`passport.protocols.${name}`) || {};\n\n    return {\n      name,\n      useStrategy,\n      settings: {\n        ...settings,\n        passReqToCallback: true\n      }\n    };\n  }\n\n  /**\n   * Create the verifier handler for passport\n   * @param provider\n   * @private\n   */\n  private createHandler(provider: Provider) {\n    const middleware = this.platformHandler.createCustomHandler(provider, \"$onVerify\");\n\n    return async (req: any, ...args: any[]) => {\n      const done = args[args.length - 1];\n\n      if (req.$ctx) {\n        req.$ctx.set(\"PROTOCOL_ARGS\", args.slice(0, -1));\n\n        try {\n          await middleware(req.$ctx);\n\n          done(null, ...[].concat(req.$ctx.data));\n        } catch (err) {\n          done(err, false, {message: err.message});\n        }\n      } else {\n        done(new Error(\"Headers already sent\"), false, {message: \"Headers already sent\"});\n      }\n    };\n  }\n}\n"]}