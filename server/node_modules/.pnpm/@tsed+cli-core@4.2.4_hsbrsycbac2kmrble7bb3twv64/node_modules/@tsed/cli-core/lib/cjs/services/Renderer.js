"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptsRendererService = exports.SrcRendererService = exports.RootRendererService = exports.Renderer = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const consolidate_1 = tslib_1.__importDefault(require("consolidate"));
const fs_extra_1 = require("fs-extra");
const normalize_path_1 = tslib_1.__importDefault(require("normalize-path"));
const globby_1 = tslib_1.__importDefault(require("globby"));
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const CliFs_1 = require("./CliFs");
require("../utils/hbs");
const insertImport_1 = require("../utils/renderer/insertImport");
const insertAfter_1 = require("../utils/renderer/insertAfter");
class Renderer {
    configuration;
    templateDir;
    fs;
    async render(path, data, options = {}) {
        const { output, templateDir, rootDir } = this.mapOptions(path, options);
        let content = "";
        const file = (0, normalize_path_1.default)((0, path_1.join)(templateDir, path));
        if (path.endsWith(".hbs")) {
            content = await consolidate_1.default.handlebars(file, data);
        }
        else {
            content = await this.fs.readFile(file, { encoding: "utf8" });
        }
        return this.write(content, { output, rootDir });
    }
    async renderAll(paths, data, options = {}) {
        let count = 0;
        const mapOptions = (opts) => {
            if ((0, core_1.isString)(opts)) {
                return { ...options, path: opts };
            }
            return {
                ...options,
                ...opts
            };
        };
        return new rxjs_1.Observable((observer) => {
            observer.next(`[${count}/${paths.length}] Rendering files...`);
            const promises = paths
                .filter(Boolean)
                .map(mapOptions)
                .map(async ({ path, ...opts }) => {
                await this.render(path, data, opts);
                count++;
                observer.next(`[${count}/${paths.length}] Rendering files...`);
            });
            Promise.all(promises)
                .then(() => {
                observer.next(`[${count}/${paths.length}] Rendering files...`);
                observer.complete();
            })
                .catch((err) => {
                observer.error(err);
            });
        });
    }
    async write(content, options) {
        const { output, rootDir = this.rootDir } = options;
        const outputFile = (0, path_1.join)(...[rootDir, output].filter(Boolean));
        await this.fs.ensureDir((0, path_1.dirname)(outputFile));
        return this.fs.writeFile(outputFile, content, { encoding: "utf8" });
    }
    templateExists(path, options = {}) {
        const { templateDir } = this.mapOptions(path, options);
        return (0, fs_extra_1.existsSync)((0, path_1.join)(templateDir, path));
    }
    async scan(pattern, options = {}) {
        const result = await (0, globby_1.default)(pattern.map((s) => (0, normalize_path_1.default)(s)), {
            ...options,
            objectMode: true,
            cwd: this.rootDir
        });
        return result.map((entry) => entry.path);
    }
    relativeFrom(path) {
        return (0, path_1.relative)((0, path_1.dirname)((0, path_1.join)(this.rootDir, path)), this.rootDir);
    }
    async update(path, actions) {
        path = (0, path_1.join)(this.rootDir, path);
        if (!this.fs.exists(path)) {
            return;
        }
        const content = actions.reduce((fileContent, action) => {
            switch (action.type) {
                case "import":
                    return (0, insertImport_1.insertImport)(fileContent, action.content);
                case "insert-after":
                    return (0, insertAfter_1.insertAfter)(fileContent, action.content, action.pattern);
                default:
                    break;
            }
            return fileContent;
        }, await this.fs.readFile(path, { encoding: "utf8" }));
        return this.fs.writeFile(path, content, { encoding: "utf8" });
    }
    mapOptions(path, options) {
        const { templateDir = this.templateDir, rootDir = this.rootDir } = options;
        let { output = path } = options;
        if (options.baseDir) {
            output = (0, normalize_path_1.default)((0, path_1.join)("/", (0, path_1.relative)(options.baseDir, path)));
        }
        if (options.basename) {
            output = (0, normalize_path_1.default)((0, path_1.join)((0, path_1.dirname)(output), options.basename));
        }
        output = output.replace(/\.hbs$/, "");
        return { output, templateDir, rootDir };
    }
}
tslib_1.__decorate([
    (0, di_1.Configuration)(),
    tslib_1.__metadata("design:type", Object)
], Renderer.prototype, "configuration", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("templateDir"),
    tslib_1.__metadata("design:type", String)
], Renderer.prototype, "templateDir", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", CliFs_1.CliFs)
], Renderer.prototype, "fs", void 0);
exports.Renderer = Renderer;
let RootRendererService = class RootRendererService extends Renderer {
    get rootDir() {
        return this.configuration.project?.rootDir;
    }
};
RootRendererService = tslib_1.__decorate([
    (0, di_1.Injectable)()
], RootRendererService);
exports.RootRendererService = RootRendererService;
let SrcRendererService = class SrcRendererService extends Renderer {
    get rootDir() {
        return (0, path_1.join)(...[this.configuration.project?.rootDir, this.configuration.project?.srcDir].filter(Boolean));
    }
};
SrcRendererService = tslib_1.__decorate([
    (0, di_1.Injectable)()
], SrcRendererService);
exports.SrcRendererService = SrcRendererService;
let ScriptsRendererService = class ScriptsRendererService extends Renderer {
    get rootDir() {
        return (0, path_1.join)(...[this.configuration.project?.rootDir, this.configuration.project?.scriptsDir].filter(Boolean));
    }
};
ScriptsRendererService = tslib_1.__decorate([
    (0, di_1.Injectable)()
], ScriptsRendererService);
exports.ScriptsRendererService = ScriptsRendererService;
//# sourceMappingURL=Renderer.js.map