var CliHttpClient_1;
import { __decorate, __metadata } from "tslib";
import { Inject, Injectable } from "@tsed/di";
import axios from "axios";
import { cleanObject } from "@tsed/core";
import { stringify } from "querystring";
import { CliProxyAgent } from "./CliProxyAgent.js";
import { CliHttpLogClient } from "./CliHttpLogClient.js";
import { URL } from "url";
let CliHttpClient = CliHttpClient_1 = class CliHttpClient extends CliHttpLogClient {
    cliProxyAgent;
    host;
    static getParamsSerializer(params) {
        return stringify(cleanObject(params));
    }
    async $onInit() {
        await this.cliProxyAgent.resolveProxySettings();
    }
    async head(endpoint, options = {}) {
        const { headers } = await axios(this.getRequestParameters("HEAD", endpoint, options));
        return headers;
    }
    async get(endpoint, options = {}) {
        const result = await this.send(this.getRequestParameters("GET", endpoint, options));
        return this.mapResponse(result, options);
    }
    async post(endpoint, options = {}) {
        const result = await this.send(this.getRequestParameters("POST", endpoint, options));
        return this.mapResponse(result, options);
    }
    async put(endpoint, options = {}) {
        const result = await this.send(this.getRequestParameters("PUT", endpoint, options));
        return this.mapResponse(result, options);
    }
    async patch(endpoint, options = {}) {
        const result = await this.send(this.getRequestParameters("PATCH", endpoint, options));
        return this.mapResponse(result, options);
    }
    async delete(endpoint, options = {}) {
        const result = await this.send(this.getRequestParameters("DELETE", endpoint, options));
        return this.mapResponse(result, options);
    }
    getRequestParameters(method, endpoint, options) {
        options = {
            method,
            url: (this.host || "") + endpoint.replace(this.host || "", ""),
            ...options,
            params: options.params || options.qs,
            data: options.data,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
                ...(options.headers || {})
            }
        };
        this.configureProxy(endpoint, options);
        return options;
    }
    configureProxy(endpoint, options) {
        const url = new URL(endpoint);
        if (this.cliProxyAgent.hasProxy()) {
            const protocol = url.protocol.replace(":", "");
            switch (protocol) {
                case "https":
                    options.httpsAgent = this.cliProxyAgent.get(protocol);
                    options.proxy = false;
                    break;
                case "http":
                    options.httpAgent = this.cliProxyAgent.get(protocol);
                    options.proxy = false;
                    break;
                default:
                    break;
            }
        }
    }
    async send(options) {
        const startTime = new Date().getTime();
        try {
            const response = await axios({
                paramsSerializer: CliHttpClient_1.getParamsSerializer,
                ...options
            });
            this.onSuccess({ startTime, ...options });
            return response;
        }
        catch (error) {
            this.onError(error, { startTime, ...options });
            throw error;
        }
    }
    mapResponse(result, options) {
        const { withHeaders } = options;
        const data = !withHeaders ? result?.data : result;
        return withHeaders ? { data, headers: result?.headers } : data;
    }
};
__decorate([
    Inject(),
    __metadata("design:type", CliProxyAgent)
], CliHttpClient.prototype, "cliProxyAgent", void 0);
CliHttpClient = CliHttpClient_1 = __decorate([
    Injectable()
], CliHttpClient);
export { CliHttpClient };
//# sourceMappingURL=CliHttpClient.js.map