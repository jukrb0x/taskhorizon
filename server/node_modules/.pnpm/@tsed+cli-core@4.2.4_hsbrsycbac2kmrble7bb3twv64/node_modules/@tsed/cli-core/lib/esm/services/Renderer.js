import { __decorate, __metadata } from "tslib";
import { isString } from "@tsed/core";
import { Configuration, Constant, Inject, Injectable } from "@tsed/di";
import Consolidate from "consolidate";
import { existsSync } from "fs-extra";
import normalizePath from "normalize-path";
import globby from "globby";
import { dirname, join, relative } from "path";
import { Observable } from "rxjs";
import { CliFs } from "./CliFs.js";
import "../utils/hbs.js";
import { insertImport } from "../utils/renderer/insertImport.js";
import { insertAfter } from "../utils/renderer/insertAfter.js";
export class Renderer {
    configuration;
    templateDir;
    fs;
    async render(path, data, options = {}) {
        const { output, templateDir, rootDir } = this.mapOptions(path, options);
        let content = "";
        const file = normalizePath(join(templateDir, path));
        if (path.endsWith(".hbs")) {
            content = await Consolidate.handlebars(file, data);
        }
        else {
            content = await this.fs.readFile(file, { encoding: "utf8" });
        }
        return this.write(content, { output, rootDir });
    }
    async renderAll(paths, data, options = {}) {
        let count = 0;
        const mapOptions = (opts) => {
            if (isString(opts)) {
                return { ...options, path: opts };
            }
            return {
                ...options,
                ...opts
            };
        };
        return new Observable((observer) => {
            observer.next(`[${count}/${paths.length}] Rendering files...`);
            const promises = paths
                .filter(Boolean)
                .map(mapOptions)
                .map(async ({ path, ...opts }) => {
                await this.render(path, data, opts);
                count++;
                observer.next(`[${count}/${paths.length}] Rendering files...`);
            });
            Promise.all(promises)
                .then(() => {
                observer.next(`[${count}/${paths.length}] Rendering files...`);
                observer.complete();
            })
                .catch((err) => {
                observer.error(err);
            });
        });
    }
    async write(content, options) {
        const { output, rootDir = this.rootDir } = options;
        const outputFile = join(...[rootDir, output].filter(Boolean));
        await this.fs.ensureDir(dirname(outputFile));
        return this.fs.writeFile(outputFile, content, { encoding: "utf8" });
    }
    templateExists(path, options = {}) {
        const { templateDir } = this.mapOptions(path, options);
        return existsSync(join(templateDir, path));
    }
    async scan(pattern, options = {}) {
        const result = await globby(pattern.map((s) => normalizePath(s)), {
            ...options,
            objectMode: true,
            cwd: this.rootDir
        });
        return result.map((entry) => entry.path);
    }
    relativeFrom(path) {
        return relative(dirname(join(this.rootDir, path)), this.rootDir);
    }
    async update(path, actions) {
        path = join(this.rootDir, path);
        if (!this.fs.exists(path)) {
            return;
        }
        const content = actions.reduce((fileContent, action) => {
            switch (action.type) {
                case "import":
                    return insertImport(fileContent, action.content);
                case "insert-after":
                    return insertAfter(fileContent, action.content, action.pattern);
                default:
                    break;
            }
            return fileContent;
        }, await this.fs.readFile(path, { encoding: "utf8" }));
        return this.fs.writeFile(path, content, { encoding: "utf8" });
    }
    mapOptions(path, options) {
        const { templateDir = this.templateDir, rootDir = this.rootDir } = options;
        let { output = path } = options;
        if (options.baseDir) {
            output = normalizePath(join("/", relative(options.baseDir, path)));
        }
        if (options.basename) {
            output = normalizePath(join(dirname(output), options.basename));
        }
        output = output.replace(/\.hbs$/, "");
        return { output, templateDir, rootDir };
    }
}
__decorate([
    Configuration(),
    __metadata("design:type", Object)
], Renderer.prototype, "configuration", void 0);
__decorate([
    Constant("templateDir"),
    __metadata("design:type", String)
], Renderer.prototype, "templateDir", void 0);
__decorate([
    Inject(),
    __metadata("design:type", CliFs)
], Renderer.prototype, "fs", void 0);
let RootRendererService = class RootRendererService extends Renderer {
    get rootDir() {
        return this.configuration.project?.rootDir;
    }
};
RootRendererService = __decorate([
    Injectable()
], RootRendererService);
export { RootRendererService };
let SrcRendererService = class SrcRendererService extends Renderer {
    get rootDir() {
        return join(...[this.configuration.project?.rootDir, this.configuration.project?.srcDir].filter(Boolean));
    }
};
SrcRendererService = __decorate([
    Injectable()
], SrcRendererService);
export { SrcRendererService };
let ScriptsRendererService = class ScriptsRendererService extends Renderer {
    get rootDir() {
        return join(...[this.configuration.project?.rootDir, this.configuration.project?.scriptsDir].filter(Boolean));
    }
};
ScriptsRendererService = __decorate([
    Injectable()
], ScriptsRendererService);
export { ScriptsRendererService };
//# sourceMappingURL=Renderer.js.map