import { __decorate, __metadata, __param } from "tslib";
import { getValue, setValue } from "@tsed/core";
import { Configuration, Inject, Injectable } from "@tsed/di";
import { join } from "path";
import { EMPTY, throwError } from "rxjs";
import { catchError } from "rxjs/operators";
import semver from "semver";
import { PackageManager } from "../interfaces/ProjectPreferences.js";
import { CliExeca } from "./CliExeca.js";
import { CliFs } from "./CliFs.js";
import { isValidVersion } from "../utils/isValidVersion.js";
import { getPackageJson } from "../utils/getPackageJson.js";
function mapPackagesWithInvalidVersion(deps) {
    const toString = (info) => {
        return info[1] === "latest" ? info[0] : info.join("@");
    };
    return Object.entries(deps)
        .filter(([, version]) => !semver.valid(version))
        .map(toString);
}
function sortKeys(obj) {
    return Object.entries(obj)
        .sort((k1, k2) => {
        return k1[0] < k2[0] ? -1 : 1;
    })
        .reduce((obj, [key, value]) => {
        return {
            ...obj,
            [key]: value
        };
    }, {});
}
function mapPackagesWithValidVersion(deps) {
    return Object.entries(deps).reduce((deps, [key, version]) => {
        if (isValidVersion(version)) {
            return {
                ...deps,
                [key]: version
            };
        }
        return deps;
    }, {});
}
function defaultPreferences(pkg) {
    let packageManager = PackageManager.YARN;
    if (getValue(pkg, "scripts.build", "").includes("pnpm ")) {
        packageManager = PackageManager.PNPM;
    }
    else if (getValue(pkg, "scripts.build", "").includes("npm ")) {
        packageManager = PackageManager.NPM;
    }
    return {
        packageManager
    };
}
let ProjectPackageJson = class ProjectPackageJson {
    configuration;
    rewrite = false;
    reinstall = false;
    cliExeca;
    fs;
    GH_TOKEN;
    raw;
    constructor(configuration) {
        this.configuration = configuration;
        this.setRaw({
            name: "",
            version: "1.0.0",
            description: "",
            scripts: {},
            dependencies: {},
            devDependencies: {}
        });
        this.read();
    }
    get path() {
        return join(this.dir, "package.json");
    }
    get dir() {
        return String(this.configuration.project?.rootDir);
    }
    set dir(dir) {
        this.configuration.project.rootDir = dir;
        this.read();
    }
    get name() {
        return this.raw.name;
    }
    set name(name) {
        this.raw.name = name;
        this.rewrite = true;
    }
    get version() {
        return this.raw.version;
    }
    get description() {
        return this.raw.description;
    }
    get scripts() {
        return this.raw.scripts;
    }
    get dependencies() {
        return this.raw.dependencies;
    }
    get devDependencies() {
        return this.raw.devDependencies;
    }
    get allDependencies() {
        return {
            ...(this.dependencies || {}),
            ...(this.devDependencies || {})
        };
    }
    get preferences() {
        return this.raw[this.configuration.name];
    }
    toJSON() {
        return this.raw;
    }
    read() {
        const pkg = this.getPackageJson();
        this.setRaw(pkg);
        return this;
    }
    setRaw(pkg) {
        const projectPreferences = this.configuration.defaultProjectPreferences;
        const preferences = getValue(pkg, this.configuration.name);
        this.raw = {
            ...pkg,
            [this.configuration.name]: {
                ...defaultPreferences(pkg),
                ...(projectPreferences && projectPreferences(pkg)),
                ...preferences
            }
        };
    }
    getRunCmd() {
        switch (this.preferences.packageManager) {
            case "npm":
                return "npm run";
            case "pnpm":
                return "pnpm run";
            default:
                return "yarn run";
        }
    }
    addDevDependency(pkg, version) {
        this.devDependencies[pkg] = version;
        this.reinstall = true;
        this.rewrite = true;
        return this;
    }
    addDevDependencies(modules, scope = {}) {
        const replacer = (match, key) => getValue(key, scope);
        Object.entries(modules).forEach(([pkg, version]) => {
            this.addDevDependency(pkg, (version || "").replace(/{{([\w.]+)}}/gi, replacer));
        });
        return this;
    }
    addDependency(pkg, version) {
        this.dependencies[pkg] = version;
        this.reinstall = true;
        this.rewrite = true;
        return this;
    }
    addDependencies(modules, ctx = {}) {
        const replacer = (match, key) => getValue(key, ctx);
        Object.entries(modules).forEach(([pkg, version]) => {
            this.addDependency(pkg, (version || "").replace("{{tsedVersion}}", ctx.tsedVersion).replace(/{{([\w.]+)}}/gi, replacer));
        });
        return this;
    }
    addScript(task, cmd) {
        this.scripts[task] = cmd;
        this.rewrite = true;
        return this;
    }
    addScripts(scripts) {
        Object.entries(scripts).forEach(([task, cmd]) => {
            this.addScript(task, cmd);
        });
        return this;
    }
    add(key, data) {
        this.raw[key] = data;
        this.rewrite = true;
        return this;
    }
    setPreference(key, value) {
        setValue(this.raw, `${this.configuration.name}.${key}`, value);
        this.rewrite = true;
        return;
    }
    set(key, value) {
        this.raw[key] = value;
        this.rewrite = true;
        if (["dependencies", "devDependencies", "peerDependencies"].includes(key)) {
            this.reinstall = true;
        }
    }
    get(key) {
        return this.raw[key];
    }
    write() {
        const originalPkg = this.getPackageJson();
        this.rewrite = false;
        this.raw = {
            ...originalPkg,
            ...this.raw,
            scripts: {
                ...(originalPkg.scripts || {}),
                ...(this.raw.scripts || {})
            },
            dependencies: sortKeys({
                ...originalPkg.dependencies,
                ...mapPackagesWithValidVersion(this.raw.dependencies)
            }),
            devDependencies: sortKeys({
                ...originalPkg.devDependencies,
                ...mapPackagesWithValidVersion(this.raw.devDependencies)
            }),
            readme: undefined,
            _id: undefined
        };
        this.fs.writeFileSync(this.path, JSON.stringify(this.raw, null, 2), { encoding: "utf8" });
        return this;
    }
    hasYarn() {
        try {
            this.cliExeca.runSync(PackageManager.YARN, ["--version"]);
            return true;
        }
        catch (er) {
            return false;
        }
    }
    install(options = {}) {
        const packageManager = this.getPackageManager(options.packageManager);
        let tasks;
        switch (packageManager) {
            case "pnpm":
                tasks = this.installWithPnpm(options);
                break;
            case "npm":
                tasks = this.installWithNpm(options);
                break;
            default:
                tasks = this.installWithYarn(options);
        }
        return [
            {
                title: "Write package.json",
                enabled: () => this.rewrite,
                task: () => {
                    this.write();
                }
            },
            ...tasks,
            {
                title: "Clean",
                task: () => {
                    this.reinstall = false;
                    this.rewrite = false;
                    this.read();
                }
            }
        ];
    }
    /**
     * Import a module from the project workspace
     * @param mod
     */
    async importModule(mod) {
        return this.fs.importModule(mod, this.dir);
    }
    runScript(npmTask, { ignoreError, ...opts } = {}) {
        const options = {
            cwd: this.dir,
            ...opts
        };
        const errorPipe = () => catchError((error) => {
            if (ignoreError) {
                return EMPTY;
            }
            return throwError(error);
        });
        return this.cliExeca.run(this.getPackageManager(), ["run", npmTask], options).pipe(errorPipe());
    }
    getPackageManager(packageManager) {
        if (this.preferences.packageManager) {
            packageManager = this.preferences.packageManager;
        }
        packageManager = packageManager || PackageManager.YARN;
        if (packageManager === PackageManager.YARN && !this.hasYarn()) {
            packageManager = PackageManager.NPM;
        }
        return packageManager;
    }
    setGhToken(GH_TOKEN) {
        this.GH_TOKEN = GH_TOKEN;
    }
    installWithYarn({ verbose }) {
        const devDeps = mapPackagesWithInvalidVersion(this.devDependencies);
        const deps = mapPackagesWithInvalidVersion(this.dependencies);
        const options = {
            cwd: this.dir,
            env: {
                ...process.env,
                GH_TOKEN: this.GH_TOKEN
            }
        };
        const errorPipe = () => catchError((error) => {
            if (error.stderr.startsWith("error Your lockfile needs to be updated")) {
                return throwError(new Error("yarn.lock file is outdated. Run yarn, commit the updated lockfile and try again."));
            }
            return throwError(error);
        });
        return [
            {
                title: "Installing dependencies using Yarn",
                skip: () => !this.reinstall,
                task: () => this.cliExeca.run(PackageManager.YARN, ["install", verbose && "--verbose"].filter(Boolean), options).pipe(errorPipe())
            },
            {
                title: "Add dependencies using Yarn",
                skip: () => !deps.length,
                task: () => this.cliExeca.run(PackageManager.YARN, ["add", verbose && "--verbose", ...deps].filter(Boolean), options).pipe(errorPipe())
            },
            {
                title: "Add devDependencies using Yarn",
                skip: () => !devDeps.length,
                task: () => this.cliExeca
                    .run(PackageManager.YARN, ["add", "-D", verbose && "--verbose", ...devDeps].filter(Boolean), options)
                    .pipe(errorPipe())
            }
        ];
    }
    installWithNpm({ verbose }) {
        const devDeps = mapPackagesWithInvalidVersion(this.devDependencies);
        const deps = mapPackagesWithInvalidVersion(this.dependencies);
        const options = {
            cwd: this.dir,
            env: {
                ...process.env,
                GH_TOKEN: this.GH_TOKEN
            }
        };
        return [
            {
                title: "Installing dependencies using npm",
                skip: () => {
                    return !this.reinstall;
                },
                task: () => {
                    return this.cliExeca.run(PackageManager.NPM, ["install", "--no-production", "--legacy-peer-deps", verbose && "--verbose"].filter(Boolean), options);
                }
            },
            {
                title: "Add dependencies using npm",
                skip: () => !deps.length,
                task: () => this.cliExeca.run(PackageManager.NPM, ["install", "--save", "--legacy-peer-deps", verbose && "--verbose", ...deps].filter(Boolean), options)
            },
            {
                title: "Add devDependencies using npm",
                skip: () => !devDeps.length,
                task: () => this.cliExeca.run(PackageManager.NPM, ["install", "--save-dev", "--legacy-peer-deps", verbose && "--verbose", ...devDeps].filter(Boolean), options)
            }
        ];
    }
    installWithPnpm({ verbose }) {
        const devDeps = mapPackagesWithInvalidVersion(this.devDependencies);
        const deps = mapPackagesWithInvalidVersion(this.dependencies);
        const options = {
            cwd: this.dir,
            env: {
                ...process.env,
                GH_TOKEN: this.GH_TOKEN
            }
        };
        return [
            {
                title: "Installing dependencies using pnpm",
                skip: () => {
                    return !this.reinstall;
                },
                task: () => this.cliExeca.run(PackageManager.PNPM, ["install", "--dev", verbose && "--verbose"].filter(Boolean), options)
            },
            {
                title: "Add dependencies using pnpm",
                skip: () => !deps.length,
                task: () => this.cliExeca.run(PackageManager.PNPM, ["add", "--save-prod", verbose && "--verbose", ...deps].filter(Boolean), options)
            },
            {
                title: "Add devDependencies using pnpm",
                skip: () => !devDeps.length,
                task: () => this.cliExeca.run(PackageManager.PNPM, ["add", "--save-dev", verbose && "--verbose", ...devDeps].filter(Boolean), options)
            }
        ];
    }
    getPackageJson() {
        return getPackageJson(this.configuration);
    }
};
__decorate([
    Inject(CliExeca),
    __metadata("design:type", CliExeca)
], ProjectPackageJson.prototype, "cliExeca", void 0);
__decorate([
    Inject(CliFs),
    __metadata("design:type", CliFs)
], ProjectPackageJson.prototype, "fs", void 0);
ProjectPackageJson = __decorate([
    Injectable(),
    __param(0, Configuration()),
    __metadata("design:paramtypes", [Object])
], ProjectPackageJson);
export { ProjectPackageJson };
//# sourceMappingURL=ProjectPackageJson.js.map