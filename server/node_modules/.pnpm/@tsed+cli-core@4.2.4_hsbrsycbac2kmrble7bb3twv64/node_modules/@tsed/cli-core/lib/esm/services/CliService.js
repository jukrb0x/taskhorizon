import { __decorate, __metadata } from "tslib";
import { classOf } from "@tsed/core";
import { Constant, Inject, Injectable, InjectorService } from "@tsed/di";
import { Argument, Command } from "commander";
import Inquirer from "inquirer";
import { CommandStoreKeys } from "../domains/CommandStoreKeys.js";
import { PROVIDER_TYPE_COMMAND } from "../registries/CommandRegistry.js";
import { createSubTasks, createTasksRunner } from "../utils/createTasksRunner.js";
import { getCommandMetadata } from "../utils/getCommandMetadata.js";
import { mapCommanderArgs } from "../utils/mapCommanderArgs.js";
import { mapCommanderOptions } from "../utils/mapCommanderOptions.js";
import { parseOption } from "../utils/parseOption.js";
import { CliHooks } from "./CliHooks.js";
import { ProjectPackageJson } from "./ProjectPackageJson.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import inquirer_autocomplete_prompt from "inquirer-autocomplete-prompt";
Inquirer.registerPrompt("autocomplete", inquirer_autocomplete_prompt);
let CliService = class CliService {
    program = new Command();
    reinstallAfterRun = false;
    pkg;
    injector;
    hooks;
    projectPkg;
    commands = new Map();
    /**
     * Parse process.argv and runLifecycle action
     * @param argv
     */
    async parseArgs(argv) {
        const { program } = this;
        program.version(this.pkg.version);
        this.load();
        await program.parseAsync(argv);
    }
    /**
     * Run lifecycle
     * @param cmdName
     * @param data
     */
    async runLifecycle(cmdName, data = {}) {
        data = await this.beforePrompt(cmdName, data);
        data = await this.prompt(cmdName, data);
        await this.dispatch(cmdName, data);
    }
    async dispatch(cmdName, data) {
        try {
            await this.exec(cmdName, data);
        }
        catch (er) {
            await this.injector.emit("$onFinish", er);
            await this.injector.destroy();
            throw er;
        }
        await this.injector.emit("$onFinish");
        await this.injector.destroy();
    }
    async exec(cmdName, ctx) {
        const initialTasks = await this.getTasks(cmdName, ctx);
        if (initialTasks.length) {
            const tasks = [
                ...initialTasks,
                {
                    title: "Install dependencies",
                    enabled: () => this.reinstallAfterRun && (this.projectPkg.rewrite || this.projectPkg.reinstall),
                    task: createSubTasks(() => this.projectPkg.install(ctx), { ...ctx, concurrent: false })
                },
                ...(await this.getPostInstallTasks(cmdName, ctx))
            ];
            return createTasksRunner(tasks, this.mapContext(cmdName, ctx));
        }
    }
    /**
     * Run prompt for a given command
     * @param cmdName
     * @param ctx Initial data
     */
    async beforePrompt(cmdName, ctx = {}) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.useClass);
        const verbose = ctx.verbose;
        if (instance.$beforePrompt) {
            ctx = await instance.$beforePrompt(JSON.parse(JSON.stringify(ctx)));
            ctx.verbose = verbose;
        }
        return ctx;
    }
    /**
     * Run prompt for a given command
     * @param cmdName
     * @param ctx Initial data
     */
    async prompt(cmdName, ctx = {}) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.useClass);
        if (instance.$prompt) {
            const questions = [
                ...(await instance.$prompt(ctx)),
                ...(await this.hooks.emit(CommandStoreKeys.PROMPT_HOOKS, cmdName, ctx))
            ];
            if (questions.length) {
                ctx = {
                    ...ctx,
                    ...(await Inquirer.prompt(questions))
                };
            }
        }
        return ctx;
    }
    /**
     * Run lifecycle
     * @param cmdName
     * @param ctx
     */
    async getTasks(cmdName, ctx) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.token);
        ctx = this.mapContext(cmdName, ctx);
        if (instance.$beforeExec) {
            await instance.$beforeExec(ctx);
        }
        return [...(await instance.$exec(ctx)), ...(await this.hooks.emit(CommandStoreKeys.EXEC_HOOKS, cmdName, ctx))];
    }
    async getPostInstallTasks(cmdName, ctx) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.useClass);
        ctx = this.mapContext(cmdName, ctx);
        return [
            ...(instance.$postInstall ? await instance.$postInstall(ctx) : []),
            ...(await this.hooks.emit(CommandStoreKeys.POST_INSTALL_HOOKS, cmdName, ctx)),
            ...(instance.$afterPostInstall ? await instance.$afterPostInstall(ctx) : [])
        ];
    }
    createCommand(metadata) {
        const { args, name, options, description, alias, allowUnknownOption } = metadata;
        if (this.commands.has(name)) {
            return this.commands.get(name).command;
        }
        let cmd = this.program.command(name);
        const onAction = (...commanderArgs) => {
            const [, ...rawArgs] = cmd.args;
            const data = {
                verbose: !!this.program.opts().verbose,
                ...mapCommanderArgs(args, commanderArgs),
                ...mapCommanderOptions(this.program.commands),
                rawArgs
            };
            return this.runLifecycle(name, data);
        };
        if (alias) {
            cmd = cmd.alias(alias);
        }
        cmd = cmd.description(description);
        cmd = this.buildArguments(cmd, args);
        cmd = cmd.action(onAction);
        if (options) {
            cmd = this.buildOption(cmd, options, !!allowUnknownOption);
        }
        return cmd;
    }
    load() {
        this.injector.getProviders(PROVIDER_TYPE_COMMAND).forEach((provider) => this.build(provider));
    }
    mapContext(cmdName, ctx) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.useClass);
        const verbose = ctx.verbose;
        if (instance.$mapContext) {
            ctx = instance.$mapContext(JSON.parse(JSON.stringify(ctx)));
            ctx.verbose = verbose;
        }
        if (ctx.verbose) {
            this.injector.logger.level = "debug";
        }
        else {
            this.injector.logger.level = "info";
        }
        return ctx;
    }
    /**
     * Build command and sub-commands
     * @param provider
     */
    build(provider) {
        const metadata = getCommandMetadata(provider.useClass);
        if (metadata.name) {
            if (this.commands.has(metadata.name)) {
                throw Error(`The ${metadata.name} command is already registered. Change your command name used by the class ${classOf(provider.useClass)}`);
            }
            provider.command = this.createCommand(metadata);
            this.commands.set(metadata.name, provider);
        }
    }
    /**
     * Build sub-command options
     * @param subCommand
     * @param options
     * @param allowUnknownOptions
     */
    buildOption(subCommand, options, allowUnknownOptions) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        Object.entries(options).reduce((subCommand, [flags, { description, required, customParser, defaultValue, ...options }]) => {
            const fn = (v) => parseOption(v, options);
            if (options.type === Boolean) {
                defaultValue = false;
            }
            return required
                ? subCommand.requiredOption(flags, description, fn, defaultValue)
                : subCommand.option(flags, description, fn, defaultValue);
        }, subCommand);
        subCommand.option("-r, --root-dir <path>", "Project root directory");
        subCommand.option("--verbose", "Verbose mode", () => true);
        if (allowUnknownOptions) {
            subCommand.allowUnknownOption(true);
        }
        return subCommand;
    }
    buildArguments(cmd, args) {
        return Object.entries(args).reduce((cmd, [key, { description, required, defaultValue }]) => {
            const argument = new Argument(required ? `<${key}>` : `[${key}]`, description);
            if (defaultValue !== undefined) {
                argument.default(defaultValue);
            }
            return cmd.addArgument(argument);
        }, cmd);
    }
};
__decorate([
    Constant("project.reinstallAfterRun", false),
    __metadata("design:type", Object)
], CliService.prototype, "reinstallAfterRun", void 0);
__decorate([
    Constant("pkg", { version: "1.0.0" }),
    __metadata("design:type", Object)
], CliService.prototype, "pkg", void 0);
__decorate([
    Inject(),
    __metadata("design:type", InjectorService)
], CliService.prototype, "injector", void 0);
__decorate([
    Inject(),
    __metadata("design:type", CliHooks)
], CliService.prototype, "hooks", void 0);
__decorate([
    Inject(),
    __metadata("design:type", ProjectPackageJson)
], CliService.prototype, "projectPkg", void 0);
CliService = __decorate([
    Injectable()
], CliService);
export { CliService };
//# sourceMappingURL=CliService.js.map