"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliProxyAgent = void 0;
const tslib_1 = require("tslib");
const tunnel_1 = tslib_1.__importDefault(require("tunnel"));
const di_1 = require("@tsed/di");
const CliExeca_1 = require("./CliExeca");
const change_case_1 = require("change-case");
const url_1 = require("url");
function cast(value) {
    if (["undefined"].includes(value)) {
        return undefined;
    }
    if (["null"].includes(value)) {
        return null;
    }
    if (["false"].includes(value)) {
        return false;
    }
    if (["true"].includes(value)) {
        return false;
    }
    return value;
}
let CliProxyAgent = class CliProxyAgent {
    proxySettings;
    cliExeca;
    hasProxy() {
        return !!this.proxySettings.url;
    }
    get(type) {
        if (this.hasProxy()) {
            const { strictSsl = true } = this.proxySettings;
            const url = new url_1.URL(this.proxySettings.url);
            const protocol = url.protocol.replace(":", "");
            const options = {
                proxy: {
                    host: url.hostname,
                    port: (url.port ? +url.port : undefined),
                    proxyAuth: url.username && url.password ? `${url.username}:${url.password}` : undefined,
                    rejectUnauthorized: strictSsl
                }
            };
            const method = (0, change_case_1.camelCase)([type, "over", protocol].join(" "));
            if (tunnel_1.default[method]) {
                return tunnel_1.default[method](options);
            }
        }
        return null;
    }
    async resolveProxySettings() {
        if (this.hasProxy()) {
            return;
        }
        const result = await Promise.all([
            this.cliExeca.getAsync("npm", ["config", "get", "proxy"]),
            this.cliExeca.getAsync("npm", ["config", "get", "http-proxy"]),
            this.cliExeca.getAsync("npm", ["config", "get", "https-proxy"]),
            this.cliExeca.getAsync("npm", ["config", "get", "strict-ssl"])
        ]);
        const [proxy, httpProxy, httpsProxy, strictSsl] = result.map(cast);
        const url = httpsProxy || httpProxy || proxy;
        if (url) {
            this.proxySettings = {
                url,
                strictSsl: cast(strictSsl) !== false
            };
        }
    }
};
tslib_1.__decorate([
    (0, di_1.Value)("proxy", {}),
    tslib_1.__metadata("design:type", Object)
], CliProxyAgent.prototype, "proxySettings", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", CliExeca_1.CliExeca)
], CliProxyAgent.prototype, "cliExeca", void 0);
CliProxyAgent = tslib_1.__decorate([
    (0, di_1.Injectable)(),
    (0, di_1.Configuration)({
        proxy: {
            url: process.env.HTTPS_PROXY || process.env.HTTP_PROXY,
            strictSsl: process.env.NODE_TLS_REJECT_UNAUTHORIZED !== undefined ? process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0" : true
        }
    })
], CliProxyAgent);
exports.CliProxyAgent = CliProxyAgent;
//# sourceMappingURL=CliProxyAgent.js.map