"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliService = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const commander_1 = require("commander");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const CommandStoreKeys_1 = require("../domains/CommandStoreKeys");
const CommandRegistry_1 = require("../registries/CommandRegistry");
const createTasksRunner_1 = require("../utils/createTasksRunner");
const getCommandMetadata_1 = require("../utils/getCommandMetadata");
const mapCommanderArgs_1 = require("../utils/mapCommanderArgs");
const mapCommanderOptions_1 = require("../utils/mapCommanderOptions");
const parseOption_1 = require("../utils/parseOption");
const CliHooks_1 = require("./CliHooks");
const ProjectPackageJson_1 = require("./ProjectPackageJson");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const inquirer_autocomplete_prompt_1 = tslib_1.__importDefault(require("inquirer-autocomplete-prompt"));
inquirer_1.default.registerPrompt("autocomplete", inquirer_autocomplete_prompt_1.default);
let CliService = class CliService {
    program = new commander_1.Command();
    reinstallAfterRun = false;
    pkg;
    injector;
    hooks;
    projectPkg;
    commands = new Map();
    /**
     * Parse process.argv and runLifecycle action
     * @param argv
     */
    async parseArgs(argv) {
        const { program } = this;
        program.version(this.pkg.version);
        this.load();
        await program.parseAsync(argv);
    }
    /**
     * Run lifecycle
     * @param cmdName
     * @param data
     */
    async runLifecycle(cmdName, data = {}) {
        data = await this.beforePrompt(cmdName, data);
        data = await this.prompt(cmdName, data);
        await this.dispatch(cmdName, data);
    }
    async dispatch(cmdName, data) {
        try {
            await this.exec(cmdName, data);
        }
        catch (er) {
            await this.injector.emit("$onFinish", er);
            await this.injector.destroy();
            throw er;
        }
        await this.injector.emit("$onFinish");
        await this.injector.destroy();
    }
    async exec(cmdName, ctx) {
        const initialTasks = await this.getTasks(cmdName, ctx);
        if (initialTasks.length) {
            const tasks = [
                ...initialTasks,
                {
                    title: "Install dependencies",
                    enabled: () => this.reinstallAfterRun && (this.projectPkg.rewrite || this.projectPkg.reinstall),
                    task: (0, createTasksRunner_1.createSubTasks)(() => this.projectPkg.install(ctx), { ...ctx, concurrent: false })
                },
                ...(await this.getPostInstallTasks(cmdName, ctx))
            ];
            return (0, createTasksRunner_1.createTasksRunner)(tasks, this.mapContext(cmdName, ctx));
        }
    }
    /**
     * Run prompt for a given command
     * @param cmdName
     * @param ctx Initial data
     */
    async beforePrompt(cmdName, ctx = {}) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.useClass);
        const verbose = ctx.verbose;
        if (instance.$beforePrompt) {
            ctx = await instance.$beforePrompt(JSON.parse(JSON.stringify(ctx)));
            ctx.verbose = verbose;
        }
        return ctx;
    }
    /**
     * Run prompt for a given command
     * @param cmdName
     * @param ctx Initial data
     */
    async prompt(cmdName, ctx = {}) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.useClass);
        if (instance.$prompt) {
            const questions = [
                ...(await instance.$prompt(ctx)),
                ...(await this.hooks.emit(CommandStoreKeys_1.CommandStoreKeys.PROMPT_HOOKS, cmdName, ctx))
            ];
            if (questions.length) {
                ctx = {
                    ...ctx,
                    ...(await inquirer_1.default.prompt(questions))
                };
            }
        }
        return ctx;
    }
    /**
     * Run lifecycle
     * @param cmdName
     * @param ctx
     */
    async getTasks(cmdName, ctx) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.token);
        ctx = this.mapContext(cmdName, ctx);
        if (instance.$beforeExec) {
            await instance.$beforeExec(ctx);
        }
        return [...(await instance.$exec(ctx)), ...(await this.hooks.emit(CommandStoreKeys_1.CommandStoreKeys.EXEC_HOOKS, cmdName, ctx))];
    }
    async getPostInstallTasks(cmdName, ctx) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.useClass);
        ctx = this.mapContext(cmdName, ctx);
        return [
            ...(instance.$postInstall ? await instance.$postInstall(ctx) : []),
            ...(await this.hooks.emit(CommandStoreKeys_1.CommandStoreKeys.POST_INSTALL_HOOKS, cmdName, ctx)),
            ...(instance.$afterPostInstall ? await instance.$afterPostInstall(ctx) : [])
        ];
    }
    createCommand(metadata) {
        const { args, name, options, description, alias, allowUnknownOption } = metadata;
        if (this.commands.has(name)) {
            return this.commands.get(name).command;
        }
        let cmd = this.program.command(name);
        const onAction = (...commanderArgs) => {
            const [, ...rawArgs] = cmd.args;
            const data = {
                verbose: !!this.program.opts().verbose,
                ...(0, mapCommanderArgs_1.mapCommanderArgs)(args, commanderArgs),
                ...(0, mapCommanderOptions_1.mapCommanderOptions)(this.program.commands),
                rawArgs
            };
            return this.runLifecycle(name, data);
        };
        if (alias) {
            cmd = cmd.alias(alias);
        }
        cmd = cmd.description(description);
        cmd = this.buildArguments(cmd, args);
        cmd = cmd.action(onAction);
        if (options) {
            cmd = this.buildOption(cmd, options, !!allowUnknownOption);
        }
        return cmd;
    }
    load() {
        this.injector.getProviders(CommandRegistry_1.PROVIDER_TYPE_COMMAND).forEach((provider) => this.build(provider));
    }
    mapContext(cmdName, ctx) {
        const provider = this.commands.get(cmdName);
        const instance = this.injector.get(provider.useClass);
        const verbose = ctx.verbose;
        if (instance.$mapContext) {
            ctx = instance.$mapContext(JSON.parse(JSON.stringify(ctx)));
            ctx.verbose = verbose;
        }
        if (ctx.verbose) {
            this.injector.logger.level = "debug";
        }
        else {
            this.injector.logger.level = "info";
        }
        return ctx;
    }
    /**
     * Build command and sub-commands
     * @param provider
     */
    build(provider) {
        const metadata = (0, getCommandMetadata_1.getCommandMetadata)(provider.useClass);
        if (metadata.name) {
            if (this.commands.has(metadata.name)) {
                throw Error(`The ${metadata.name} command is already registered. Change your command name used by the class ${(0, core_1.classOf)(provider.useClass)}`);
            }
            provider.command = this.createCommand(metadata);
            this.commands.set(metadata.name, provider);
        }
    }
    /**
     * Build sub-command options
     * @param subCommand
     * @param options
     * @param allowUnknownOptions
     */
    buildOption(subCommand, options, allowUnknownOptions) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        Object.entries(options).reduce((subCommand, [flags, { description, required, customParser, defaultValue, ...options }]) => {
            const fn = (v) => (0, parseOption_1.parseOption)(v, options);
            if (options.type === Boolean) {
                defaultValue = false;
            }
            return required
                ? subCommand.requiredOption(flags, description, fn, defaultValue)
                : subCommand.option(flags, description, fn, defaultValue);
        }, subCommand);
        subCommand.option("-r, --root-dir <path>", "Project root directory");
        subCommand.option("--verbose", "Verbose mode", () => true);
        if (allowUnknownOptions) {
            subCommand.allowUnknownOption(true);
        }
        return subCommand;
    }
    buildArguments(cmd, args) {
        return Object.entries(args).reduce((cmd, [key, { description, required, defaultValue }]) => {
            const argument = new commander_1.Argument(required ? `<${key}>` : `[${key}]`, description);
            if (defaultValue !== undefined) {
                argument.default(defaultValue);
            }
            return cmd.addArgument(argument);
        }, cmd);
    }
};
tslib_1.__decorate([
    (0, di_1.Constant)("project.reinstallAfterRun", false),
    tslib_1.__metadata("design:type", Object)
], CliService.prototype, "reinstallAfterRun", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("pkg", { version: "1.0.0" }),
    tslib_1.__metadata("design:type", Object)
], CliService.prototype, "pkg", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], CliService.prototype, "injector", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", CliHooks_1.CliHooks)
], CliService.prototype, "hooks", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", ProjectPackageJson_1.ProjectPackageJson)
], CliService.prototype, "projectPkg", void 0);
CliService = tslib_1.__decorate([
    (0, di_1.Injectable)()
], CliService);
exports.CliService = CliService;
//# sourceMappingURL=CliService.js.map