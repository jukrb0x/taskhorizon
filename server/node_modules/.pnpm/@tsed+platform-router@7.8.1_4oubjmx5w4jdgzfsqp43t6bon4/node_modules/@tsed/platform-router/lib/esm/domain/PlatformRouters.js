import { __decorate, __metadata } from "tslib";
import { getValue, Hooks } from "@tsed/core";
import { ControllerProvider, GlobalProviders, Injectable, InjectorService, ProviderType } from "@tsed/di";
import { concatPath, getOperationsRoutes } from "@tsed/schema";
import { useContextHandler } from "../utils/useContextHandler.js";
import { PlatformLayer } from "./PlatformLayer.js";
import { PlatformRouter } from "./PlatformRouter.js";
let AUTO_INC = 0;
function getInjectableRouter(injector, provider) {
    return injector.get(provider.tokenRouter);
}
function createTokenRouter(provider) {
    return (provider.tokenRouter = provider.tokenRouter || `${provider.name}_ROUTER_${AUTO_INC++}`);
}
function createInjectableRouter(injector, provider) {
    const tokenRouter = createTokenRouter(provider);
    if (injector.has(tokenRouter)) {
        return getInjectableRouter(injector, provider);
    }
    const router = injector.invoke(PlatformRouter);
    router.provider = provider;
    return injector
        .add(tokenRouter, {
        useValue: router
    })
        .invoke(tokenRouter);
}
GlobalProviders.createRegistry(ProviderType.CONTROLLER, ControllerProvider, {
    onInvoke(provider, locals, { injector }) {
        const router = createInjectableRouter(injector, provider);
        locals.set(PlatformRouter, router);
    }
});
let PlatformRouters = class PlatformRouters {
    injector;
    hooks = new Hooks();
    constructor(injector) {
        this.injector = injector;
    }
    prebuild() {
        this.injector.getProviders(ProviderType.CONTROLLER).forEach((provider) => {
            createInjectableRouter(this.injector, provider);
        });
    }
    from(token, parentMiddlewares = []) {
        const { injector } = this;
        const provider = injector.getProvider(token);
        if (!provider) {
            throw new Error("Token not found in the provider registry");
        }
        const router = createInjectableRouter(injector, provider);
        if (router.isBuilt()) {
            return router;
        }
        const useBefore = getValue(provider, "middlewares.useBefore", []);
        const { children } = provider;
        getOperationsRoutes(provider.token).forEach((operationRoute) => {
            const { endpoint } = operationRoute;
            const { beforeMiddlewares, middlewares: mldwrs, afterMiddlewares } = endpoint;
            const useBefore = getValue(provider, "middlewares.useBefore", []);
            const use = getValue(provider, "middlewares.use", []);
            const useAfter = getValue(provider, "middlewares.useAfter", []);
            const handlers = this.hooks.alter("alterEndpointHandlers", [
                ...parentMiddlewares,
                ...useBefore,
                ...beforeMiddlewares,
                ...use,
                ...mldwrs,
                operationRoute.endpoint,
                ...afterMiddlewares,
                ...useAfter
            ], [operationRoute], this);
            router.addRoute(operationRoute.method, operationRoute.path || "", [
                useContextHandler(($ctx) => {
                    $ctx.endpoint = operationRoute.endpoint;
                }),
                ...handlers
            ], operationRoute);
        });
        const middlewares = [...parentMiddlewares, ...useBefore];
        children.forEach((token) => {
            const nested = this.from(token, middlewares);
            router.use(nested);
        });
        return router;
    }
    getLayers(router) {
        return router.layers
            .flatMap((layer) => {
            if (layer.router) {
                return this.getLayers(layer.router).map((subLayer) => {
                    return new PlatformLayer({
                        ...subLayer,
                        path: concatPath(layer.path, subLayer.path)
                    });
                });
            }
            return new PlatformLayer(layer);
        })
            .map((layer) => {
            const handlers = layer.handlers.map((handlerMetadata) => {
                // set path on handler metadata to retrieve it later in $ctx
                handlerMetadata.path = layer.path;
                return this.hooks.alter("alterHandler", handlerMetadata);
            });
            layer.set(handlers);
            return layer;
        });
    }
};
PlatformRouters = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [InjectorService])
], PlatformRouters);
export { PlatformRouters };
//# sourceMappingURL=PlatformRouters.js.map