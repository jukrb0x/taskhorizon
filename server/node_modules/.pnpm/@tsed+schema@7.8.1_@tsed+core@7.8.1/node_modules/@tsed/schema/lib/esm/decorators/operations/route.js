import { DecoratorContext } from "../../domain/DecoratorContext.js";
import { mapRouteOptions } from "../../utils/mapRouteOptions.js";
import { OperationMethods } from "../../constants/httpMethods.js";
class RouteDecoratorContext extends DecoratorContext {
    methods = ["name", "description", "summary", "method", "id", "use", "useAfter", "useBefore"];
    beforeInit() {
        const path = this.get("path");
        const method = OperationMethods[this.get("method")] || OperationMethods.CUSTOM;
        path && this.entity.operation.addOperationPath(method, path);
    }
    onMapKey(key, value) {
        switch (key) {
            case "name":
            case "id":
                this.entity.operation.operationId(value);
                return;
            case "summary":
                this.entity.operation.summary(value);
                return;
            case "description":
                this.entity.operation.description(value);
                return;
            case "use":
                this.entity.use(value);
                return;
            case "useAfter":
                this.entity.after(value);
                return;
            case "useBefore":
                this.entity.before(value);
                return;
        }
        return super.onMapKey(key, value);
    }
}
export function Route(...args) {
    const routeOptions = mapRouteOptions(args);
    const context = new RouteDecoratorContext(routeOptions);
    return context.build();
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
export function All(path = "/", ...args) {
    return Route(...[OperationMethods.ALL, path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
export function Get(path = "/", ...args) {
    return Route(...[OperationMethods.GET, path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
export function Post(path = "/", ...args) {
    return Route(...[OperationMethods.POST, path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
export function Put(path = "/", ...args) {
    return Route(...[OperationMethods.PUT, path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
export function Delete(path = "/", ...args) {
    return Route(...[OperationMethods.DELETE, path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
export function Head(path = "/", ...args) {
    return Route(...[OperationMethods.HEAD, path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
export function Patch(path = "/", ...args) {
    return Route(...[OperationMethods.PATCH, path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
export function Options(path = "/", ...args) {
    return Route(...[OperationMethods.OPTIONS, path].concat(args));
}
//# sourceMappingURL=route.js.map