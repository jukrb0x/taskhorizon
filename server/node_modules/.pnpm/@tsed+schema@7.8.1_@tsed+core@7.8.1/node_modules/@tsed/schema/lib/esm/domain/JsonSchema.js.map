{"version":3,"file":"JsonSchema.js","sourceRoot":"","sources":["../../../src/domain/JsonSchema.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ancestorsOf,\n  classOf,\n  Hooks,\n  isArray,\n  isClass,\n  isFunction,\n  isObject,\n  isPrimitiveClass,\n  nameOf,\n  Type,\n  uniq,\n  ValueOf\n} from \"@tsed/core\";\nimport type {JSONSchema6, JSONSchema6Definition, JSONSchema6Type, JSONSchema6TypeName, JSONSchema6Version} from \"json-schema\";\nimport {IgnoreCallback} from \"../interfaces/IgnoreCallback\";\nimport {JsonSchemaOptions} from \"../interfaces/JsonSchemaOptions\";\nimport {execMapper} from \"../registries/JsonSchemaMapperContainer\";\nimport {NestedGenerics} from \"../utils/generics\";\nimport {getComputedType} from \"../utils/getComputedType\";\nimport {getJsonType} from \"../utils/getJsonType\";\nimport {serializeEnumValues} from \"../utils/serializeEnumValues\";\nimport {toJsonRegex} from \"../utils/toJsonRegex\";\nimport {AliasMap, AliasType} from \"./JsonAliasMap\";\nimport {Discriminator} from \"./JsonDiscriminator\";\nimport {JsonEntityStore} from \"./JsonEntityStore\";\nimport {JsonFormatTypes} from \"./JsonFormatTypes\";\nimport {JsonLazyRef} from \"./JsonLazyRef\";\n\nexport interface JsonSchemaObject extends JSONSchema6, Record<string, any> {\n  type: (any | JSONSchema6TypeName) | (any | JSONSchema6TypeName)[];\n  additionalProperties?: boolean | JSONSchema6 | any;\n  propertyNames?: boolean | JSONSchema6 | any;\n  items?: (any | JSONSchema6Definition) | (any | JSONSchema6Definition)[];\n}\n\nexport type AnyJsonSchema = Partial<JsonSchemaObject> | JsonSchema | JsonLazyRef | any;\n\nfunction mapProperties(properties: Record<string, any>) {\n  // istanbul ignore next\n  if (properties instanceof JsonSchema) {\n    return properties;\n  }\n\n  return Object.entries(properties).reduce<any>((properties, [key, schema]) => {\n    properties[toJsonRegex(key)] = mapToJsonSchema(schema);\n\n    return properties;\n  }, {});\n}\n\nfunction mapToJsonSchema(item: any): any {\n  if (isArray(item)) {\n    return (item as any[]).map(mapToJsonSchema);\n  }\n\n  if (item.isStore || item.isJsonSchema || item.isLazyRef) {\n    return item;\n  }\n\n  if (classOf(item) !== Object && isClass(item)) {\n    return JsonEntityStore.from(item).schema;\n  }\n\n  if (isObject(item)) {\n    return JsonSchema.from(item as any);\n  }\n\n  if (isPrimitiveClass(item)) {\n    return JsonSchema.from({type: item});\n  }\n\n  return item;\n}\n\nexport class JsonSchema extends Map<string, any> implements NestedGenerics {\n  readonly isJsonSchema = true;\n  readonly $hooks = new Hooks();\n  readonly $required: Set<string> = new Set();\n  readonly $allow: any[] = [];\n  public $selfRequired: boolean;\n  public $forwardGroups: boolean = false;\n\n  public isDiscriminatorKey = false;\n  public isDiscriminator = false;\n\n  #nullable: boolean = false;\n  #discriminator: null | Discriminator = null;\n  #genericLabels: string[];\n  #nestedGenerics: Type<any>[][] = [];\n  #alias: AliasMap = new Map();\n  #itemSchema: JsonSchema;\n  #target: Type<any>;\n  #isGeneric: boolean = false;\n  #isCollection: boolean = false;\n  #ref: boolean = false;\n\n  constructor(obj: JsonSchema | Partial<JsonSchemaObject> = {}) {\n    super();\n\n    if (obj) {\n      this.assign(obj);\n    }\n  }\n\n  get alias() {\n    return this.#alias;\n  }\n\n  get nestedGenerics(): any[] {\n    return this.#nestedGenerics;\n  }\n\n  set nestedGenerics(value: any[]) {\n    this.#nestedGenerics = value;\n  }\n\n  get genericLabels(): string[] {\n    return this.#genericLabels;\n  }\n\n  set genericLabels(value: string[]) {\n    this.#genericLabels = value;\n  }\n\n  get isClass() {\n    return isClass(this.class) && ![Map, Array, Set, Object, Date, Boolean, Number, String].includes(this.#target as any);\n  }\n\n  /**\n   * Current schema is a collection\n   */\n  get isCollection() {\n    return this.#isCollection;\n  }\n\n  /**\n   * Current schema is a generic\n   */\n  get isGeneric() {\n    return this.#isGeneric;\n  }\n\n  get discriminatorAncestor() {\n    const ancestors = ancestorsOf(this.#target);\n    const ancestor = ancestors.find((ancestor) => JsonEntityStore.from(ancestor).schema.isDiscriminator);\n    return ancestor && JsonEntityStore.from(ancestor).schema;\n  }\n\n  /**\n   * Current schema has generics items\n   */\n  get hasGenerics(): boolean {\n    return !!(this.nestedGenerics && this.nestedGenerics.length);\n  }\n\n  get genericType(): string {\n    return this.get(\"$ref\");\n  }\n\n  get class() {\n    return this.getComputedType();\n  }\n\n  get canRef(): boolean {\n    return this.#ref;\n  }\n\n  get isNullable(): boolean {\n    return this.#nullable || this.$allow.includes(null);\n  }\n\n  get isReadOnly() {\n    return this.get(\"readOnly\");\n  }\n\n  get isWriteOnly() {\n    return this.get(\"writeOnly\");\n  }\n\n  static from(obj: Partial<JsonSchemaObject> = {}) {\n    return new JsonSchema(obj);\n  }\n\n  nullable(value: boolean) {\n    this.#nullable = value;\n  }\n\n  itemSchema(obj: AnyJsonSchema = {}) {\n    this.#itemSchema = this.#itemSchema || mapToJsonSchema(obj);\n    this.#itemSchema.assign(obj);\n\n    return this.#itemSchema;\n  }\n\n  getAliasOf(property: AliasType) {\n    return this.#alias.get(property as any);\n  }\n\n  addAlias(property: AliasType, alias: AliasType) {\n    this.#alias.set(property, alias);\n    this.#alias.set(alias, property);\n\n    return this;\n  }\n\n  removeAlias(property: AliasType) {\n    const alias = this.#alias.get(property);\n    alias && this.#alias.delete(alias);\n    this.#alias.delete(property);\n\n    return this;\n  }\n\n  $id($id: string) {\n    super.set(\"$id\", $id);\n\n    return this;\n  }\n\n  $ref($ref: string) {\n    super.set(\"$ref\", $ref);\n\n    return this;\n  }\n\n  $schema($schema: JSONSchema6Version) {\n    super.set(\"$schema\", $schema);\n\n    return this;\n  }\n\n  /**\n   * Create a ref and use name to sharing schema\n   * @param name\n   */\n  label(name: string) {\n    this.#ref = true;\n\n    super.set(\"name\", name);\n\n    return this;\n  }\n\n  name(name: string) {\n    super.set(\"name\", name);\n\n    return this;\n  }\n\n  ignore(cb: boolean | IgnoreCallback) {\n    if (typeof cb === \"boolean\") {\n      const bool = cb;\n      cb = () => bool;\n    }\n\n    this.$hooks.on(\"ignore\", cb);\n\n    return this;\n  }\n\n  /**\n   * This keyword can be used to supply a default JSON value associated with a particular schema.\n   * It is RECOMMENDED that a default value be valid against the associated schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.3\n   */\n  default(value: JSONSchema6Type) {\n    super.set(\"default\", value);\n\n    return this;\n  }\n\n  /**\n   * More readible form of a one-element \"enum\"\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.24\n   */\n  const(value: JSONSchema6Type) {\n    super.set(\"const\", value);\n\n    return this;\n  }\n\n  /**\n   * This attribute is a string that provides a full description of the of purpose the instance property.\n   *\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2\n   */\n  description(description: string) {\n    super.set(\"description\", description);\n\n    return this;\n  }\n\n  discriminator() {\n    this.isDiscriminator = true;\n    return (this.#discriminator =\n      this.#discriminator ||\n      new Discriminator({\n        base: this.#target\n      }));\n  }\n\n  discriminatorKey(propertyName: string) {\n    this.discriminator().propertyName = propertyName;\n    this.isDiscriminator = true;\n\n    return this;\n  }\n\n  discriminatorValue(...values: string[]) {\n    const discriminator = this.discriminatorAncestor.discriminator();\n    discriminator.add(this.#target, values);\n\n    this.isDiscriminator = true;\n\n    const properties = this.get(\"properties\");\n    const schema: JsonSchema =\n      properties[discriminator.propertyName] ||\n      new JsonSchema({\n        type: \"string\"\n      });\n\n    if (values.length === 1) {\n      schema.const(values[0]);\n      schema.examples([values[0]]);\n    } else {\n      schema.enum(...values);\n      schema.examples(values);\n    }\n\n    properties[discriminator.propertyName] = schema;\n\n    this.set(\"properties\", properties);\n\n    return this;\n  }\n\n  /**\n   * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.\n   * If \"items\" is an array of schemas, validation succeeds if every instance element\n   * at a position greater than the size of \"items\" validates against \"additionalItems\".\n   * Otherwise, \"additionalItems\" MUST be ignored, as the \"items\" schema\n   * (possibly the default value of an empty schema) is applied to all elements.\n   * Omitting this keyword has the same behavior as an empty schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.10\n   */\n  additionalItems(additionalItems: boolean | AnyJsonSchema) {\n    super.set(\"additionalItems\", mapToJsonSchema(additionalItems));\n\n    return this;\n  }\n\n  /**\n   * An array instance is valid against \"contains\" if at least one of its elements is valid against the given schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.14\n   */\n  contains(contains: JSONSchema6Definition) {\n    super.set(\"contains\", mapToJsonSchema(contains));\n\n    return this;\n  }\n\n  /**\n   * Array of examples with no validation effect the value of \"default\" is usable as an example without repeating it under this keyword\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.4\n   */\n  examples(examples: JSONSchema6Type[]) {\n    super.set(\"examples\", examples);\n\n    return this;\n  }\n\n  /**\n   * Array of examples with no validation effect the value of \"default\" is usable as an example without repeating it under this keyword\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.4\n   */\n  example(...examples: JSONSchema6Type[]) {\n    return this.examples(examples);\n  }\n\n  /**\n   * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.\n   * Omitting this keyword has the same behavior as an empty schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.9\n   */\n  items(items: AnyJsonSchema | AnyJsonSchema[]) {\n    super.set(\"items\", (this.#itemSchema = mapToJsonSchema(items)));\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * An array instance is valid against \"maxItems\" if its size is less than, or equal to, the value of this keyword.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.11\n   */\n  maxItems(maxItems: number) {\n    super.set(\"maxItems\", maxItems);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * An array instance is valid against \"maxItems\" if its size is greater than, or equal to, the value of this keyword.\n   * Omitting this keyword has the same behavior as a value of 0.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.12\n   */\n  minItems(minItems: number) {\n    super.set(\"minItems\", minItems);\n\n    return this;\n  }\n\n  /**\n   * If this keyword has boolean value false, the instance validates successfully.\n   * If it has boolean value true, the instance validates successfully if all of its elements are unique.\n   * Omitting this keyword has the same behavior as a value of false.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.13\n   */\n  uniqueItems(uniqueItems: boolean) {\n    super.set(\"uniqueItems\", uniqueItems);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * An object instance is valid against \"maxProperties\" if its number of properties is less than, or equal to, the value of this keyword.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.15\n   */\n  maxProperties(maxProperties: number) {\n    super.set(\"maxProperties\", maxProperties);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * An object instance is valid against \"maxProperties\" if its number of properties is greater than,\n   * or equal to, the value of this keyword.\n   * Omitting this keyword has the same behavior as a value of 0.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.16\n   */\n  minProperties(minProperties: number) {\n    super.set(\"minProperties\", minProperties);\n\n    return this;\n  }\n\n  allow(...allow: any[]) {\n    this.$allow.push(...allow);\n    return this;\n  }\n\n  /**\n   * Elements of this array must be unique.\n   * An object instance is valid against this keyword if every item in the array is the name of a property in the instance.\n   * Omitting this keyword has the same behavior as an empty array.\n   *\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.17\n   */\n  required(required: boolean | string[] = true) {\n    if (isArray(required)) {\n      this.$required.clear();\n\n      required.forEach((value: any) => this.$required.add(value));\n    } else {\n      const schema = this.clone();\n      schema.$selfRequired = required;\n      return schema;\n    }\n\n    return this;\n  }\n\n  addRequired(property: string) {\n    this.$required.add(property);\n\n    return this;\n  }\n\n  removeRequired(property: string) {\n    this.$required.delete(property);\n\n    return this;\n  }\n\n  isRequired(property: string): boolean {\n    return this.$required.has(property);\n  }\n\n  /**\n   * This keyword determines how child instances validate for objects, and does not directly validate the immediate instance itself.\n   * Validation succeeds if, for each name that appears in both the instance and as a name within this keyword's value,\n   * the child instance for that name successfully validates against the corresponding schema.\n   * Omitting this keyword has the same behavior as an empty object.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.18\n   */\n  properties(properties: AnyJsonSchema | Record<string, AnyJsonSchema>) {\n    super.set(\"properties\", mapProperties(properties));\n\n    return this;\n  }\n\n  addProperty(key: string, schema: AnyJsonSchema) {\n    const properties = this.get(\"properties\") || {};\n\n    properties[key] = schema;\n\n    super.set(\"properties\", mapProperties(properties));\n\n    return this;\n  }\n\n  /**\n   * This attribute is an object that defines the schema for a set of property names of an object instance.\n   * The name of each property of this attribute's object is a regular expression pattern in the ECMA 262, while the value is a schema.\n   * If the pattern matches the name of a property on the instance object, the value of the instance's property\n   * MUST be valid against the pattern name's schema value.\n   * Omitting this keyword has the same behavior as an empty object.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.19\n   */\n  patternProperties(patternProperties: Record<string, AnyJsonSchema>) {\n    super.set(\"patternProperties\", mapProperties(patternProperties));\n\n    return this;\n  }\n\n  /**\n   * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.\n   * If specified, the value MUST be a schema or a boolean.\n   * If false is provided, no additional properties are allowed beyond the properties defined in the schema.\n   * The default value is an empty schema which allows any value for additional properties.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20\n   */\n  additionalProperties(additionalProperties: boolean | AnyJsonSchema) {\n    super.set(\"additionalProperties\", mapToJsonSchema(additionalProperties));\n\n    return this;\n  }\n\n  /**\n   * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.\n   * If specified, the value MUST be a schema or a boolean.\n   * If false is provided, no additional properties are allowed beyond the properties defined in the schema.\n   * The default value is an empty schema which allows any value for additional properties.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20\n   * @alias additionalProperties\n   * @param unknown\n   */\n  unknown(unknown: boolean = true) {\n    return this.additionalProperties(unknown);\n  }\n\n  /**\n   * This keyword specifies rules that are evaluated if the instance is an object and contains a certain property.\n   * Each property specifies a dependency.\n   * If the dependency value is an array, each element in the array must be unique.\n   * Omitting this keyword has the same behavior as an empty object.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.21\n   */\n  dependencies(dependencies: {[p: string]: JSONSchema6Definition | JsonSchema | string[]}) {\n    super.set(\"dependencies\", mapProperties(dependencies));\n\n    return this;\n  }\n\n  /**\n   * Takes a schema which validates the names of all properties rather than their values.\n   * Note the property name that the schema is testing will always be a string.\n   * Omitting this keyword has the same behavior as an empty schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.22\n   */\n  propertyNames(propertyNames: JSONSchema6Definition | JsonSchema) {\n    super.set(\"propertyNames\", mapToJsonSchema(propertyNames));\n\n    return this;\n  }\n\n  /**\n   * This provides an enumeration of all possible values that are valid\n   * for the instance property. This MUST be an array, and each item in\n   * the array represents a possible value for the instance value. If\n   * this attribute is defined, the instance value MUST be one of the\n   * values in the array in order for the schema to be valid.\n   *\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.23\n   */\n  enum(...enumValues: any[]): this;\n  enum(enumValue: any | any[], ...enumValues: any[]): this {\n    const {values, types} = serializeEnumValues([enumValue, enumValues].flat());\n\n    super.set(\"enum\", values).any(...types);\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.1\n   */\n  definitions(definitions: Record<string, AnyJsonSchema>) {\n    super.set(\"definitions\", mapProperties(definitions));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26\n   */\n  allOf(allOf: AnyJsonSchema[]) {\n    super.set(\"allOf\", allOf.map(mapToJsonSchema));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27\n   */\n  anyOf(anyOf: AnyJsonSchema[]) {\n    super.set(\"anyOf\", anyOf.map(mapToJsonSchema));\n\n    return this;\n  }\n\n  /*\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28\n   */\n  oneOf(oneOf: AnyJsonSchema[]) {\n    let resolvedOneOf = oneOf.map(mapToJsonSchema);\n\n    if (resolvedOneOf.length === 1 && !(oneOf[0] instanceof JsonSchema)) {\n      if (!resolvedOneOf[0].#discriminator) {\n        return this.type(oneOf[0]);\n      }\n\n      const children = resolvedOneOf[0].discriminator().children();\n\n      resolvedOneOf = children.map(mapToJsonSchema);\n    }\n\n    super.set(\"oneOf\", resolvedOneOf);\n\n    const jsonSchema: JsonSchema = resolvedOneOf[0];\n\n    if (jsonSchema.isDiscriminator) {\n      const discriminator = jsonSchema.discriminatorAncestor.discriminator();\n      const {propertyName} = discriminator;\n      super.set(\"discriminator\", {propertyName});\n      this.isDiscriminator = true;\n      this.#discriminator = discriminator;\n    }\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.29\n   */\n  not(not: AnyJsonSchema) {\n    super.set(\"not\", mapToJsonSchema(not));\n\n    return this;\n  }\n\n  /**\n   * Must be strictly greater than 0.\n   * A numeric instance is valid only if division by this keyword's value results in an integer.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.1\n   */\n  multipleOf(multipleOf: number): this {\n    super.set(\"multipleOf\", multipleOf);\n\n    return this;\n  }\n\n  /**\n   * Representing an inclusive upper limit for a numeric instance.\n   * This keyword validates only if the instance is less than or exactly equal to \"maximum\".\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.2\n   */\n  maximum(maximum: number): this {\n    super.set(\"maximum\", maximum);\n\n    return this;\n  }\n\n  /**\n   * Representing an exclusive upper limit for a numeric instance.\n   * This keyword validates only if the instance is strictly less than (not equal to) to \"exclusiveMaximum\".\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.3\n   */\n  exclusiveMaximum(exclusiveMaximum: number): this {\n    super.set(\"exclusiveMaximum\", exclusiveMaximum);\n\n    return this;\n  }\n\n  /**\n   * Representing an inclusive lower limit for a numeric instance.\n   * This keyword validates only if the instance is greater than or exactly equal to \"minimum\".\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.4\n   */\n  minimum(minimum: number): this {\n    super.set(\"minimum\", minimum);\n\n    return this;\n  }\n\n  /**\n   * Representing an exclusive lower limit for a numeric instance.\n   * This keyword validates only if the instance is strictly greater than (not equal to) to \"exclusiveMinimum\".\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.5\n   */\n  exclusiveMinimum(exclusiveMinimum: number): this {\n    super.set(\"exclusiveMinimum\", exclusiveMinimum);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * A string instance is valid against this keyword if its length is less than, or equal to, the value of this keyword.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.6\n   */\n  maxLength(maxLength: number): this {\n    super.set(\"maxLength\", maxLength);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.\n   * Omitting this keyword has the same behavior as a value of 0.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.7\n   */\n  minLength(minLength: number): this {\n    super.set(\"minLength\", minLength);\n\n    return this;\n  }\n\n  /**\n   * Should be a valid regular expression, according to the ECMA 262 regular expression dialect.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.8\n   */\n  pattern(pattern: string | RegExp): this {\n    super.set(\"pattern\", toJsonRegex(pattern));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-8\n   */\n  format(format: JsonFormatTypes | ValueOf<JsonFormatTypes>): this {\n    super.set(\"format\", format);\n\n    return this;\n  }\n\n  /**\n   * A single type, or a union of simple types\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.25\n   */\n  type(type: any | JSONSchema6TypeName | JSONSchema6TypeName[]): this {\n    switch (type) {\n      case Map:\n        super.set(\"type\", getJsonType(type));\n        this.#target = type;\n        this.#isCollection = true;\n        if (!this.has(\"additionalProperties\")) {\n          super.set(\"additionalProperties\", this.itemSchema({}));\n        }\n        break;\n\n      case Array:\n        super.set(\"type\", getJsonType(type));\n        this.#target = type;\n        this.#isCollection = true;\n\n        if (!this.has(\"items\")) {\n          super.set(\"items\", this.itemSchema({}));\n        }\n        break;\n\n      case Set:\n        super.set(\"type\", getJsonType(type));\n        this.#target = type;\n        this.#isCollection = true;\n        this.uniqueItems(true);\n\n        if (!this.has(\"items\")) {\n          super.set(\"items\", this.itemSchema({}));\n        }\n        break;\n\n      case \"integer\":\n        super.set(\"type\", getJsonType(type));\n        this.integer();\n        break;\n\n      case Object:\n      case Date:\n      case Boolean:\n      case Number:\n      case String:\n        super.set(\"type\", getJsonType(type));\n        this.#target = type;\n        if (!this.has(\"properties\")) {\n          super.set(\"properties\", {});\n        }\n        break;\n\n      default:\n        if (isClass(type) || isFunction(type)) {\n          super.set(\"type\", undefined);\n          this.#target = type;\n\n          if (!this.has(\"properties\")) {\n            super.set(\"properties\", {});\n          }\n        } else {\n          const jsonType = getJsonType(type);\n          if (jsonType === \"generic\") {\n            this.#isGeneric = true;\n            super.set(\"$ref\", type);\n          } else {\n            super.set(\"type\", jsonType);\n          }\n        }\n    }\n\n    return this;\n  }\n\n  any(...types: any[]) {\n    const hasClasses = types.filter((type) => isClass(type));\n\n    if (hasClasses.length >= 2) {\n      this.oneOf(\n        types.filter((value) => {\n          if (value !== null) {\n            this.nullable(true);\n            return true;\n          }\n          return false;\n        })\n      );\n    } else {\n      // TODO when OS3 will the only minimal supported version, we'll can remove this code\n      if (types.length) {\n        types = uniq(types).map(getJsonType);\n\n        if (types.includes(\"null\")) {\n          this.nullable(true);\n          types = types.filter((o) => o !== \"null\");\n        }\n      } else {\n        types = [\"integer\", \"number\", \"string\", \"boolean\", \"array\", \"object\"];\n        this.nullable(true);\n      }\n\n      this.type(types.length === 1 ? types[0] : types);\n    }\n\n    return this;\n  }\n\n  integer() {\n    super.set(\"type\", \"integer\");\n    super.set(\"multipleOf\", 1.0);\n\n    return this;\n  }\n\n  /**\n   * This attribute is a string that provides a short description of the instance property.\n   *\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2\n   */\n  title(title: string): this {\n    super.set(\"title\", title);\n\n    return this;\n  }\n\n  readOnly(readOnly: boolean): this {\n    super.set(\"readOnly\", readOnly);\n\n    return this;\n  }\n\n  writeOnly(readOnly: boolean): this {\n    super.set(\"writeOnly\", readOnly);\n\n    return this;\n  }\n\n  customKey(key: string, value: any) {\n    super.set(`#${key}`, value);\n\n    return this;\n  }\n\n  toObject(options?: JsonSchemaOptions) {\n    return this.toJSON(options);\n  }\n\n  toJSON(options?: JsonSchemaOptions) {\n    let addDef = false;\n\n    if (!options) {\n      addDef = true;\n      options = {schemas: {}};\n    }\n\n    const schema = execMapper(\"schema\", this, options);\n\n    if (addDef && options.schemas && Object.keys(options.schemas).length) {\n      schema.definitions = options.schemas;\n    }\n\n    return schema;\n  }\n\n  assign(obj: JsonSchema | Partial<JsonSchemaObject> = {}) {\n    const entries = obj instanceof JsonSchema ? [...obj.entries()] : Object.entries(obj);\n    entries.forEach(([key, value]) => {\n      this.set(key, value);\n    });\n\n    if (obj instanceof JsonSchema) {\n      this.$selfRequired = obj.$selfRequired;\n      this.$allow.push(...obj.$allow);\n\n      obj.$required.forEach((key) => {\n        this.$required.add(key);\n      });\n\n      this.#discriminator = this.#discriminator ? new Discriminator(this.#discriminator) : null;\n      this.isDiscriminator = obj.isDiscriminator;\n      this.isDiscriminatorKey = obj.isDiscriminatorKey;\n\n      this.#ref = obj.#ref;\n      this.#alias = new Map(this.#alias.entries());\n      obj.#genericLabels && (this.#genericLabels = [...obj.#genericLabels]);\n      this.#nestedGenerics = obj.#nestedGenerics.map((item) => [...item]);\n      this.#target = obj.#target;\n      this.#isGeneric = obj.#isGeneric;\n      this.#isCollection = obj.#isCollection;\n      this.#ref = obj.#ref;\n\n      super.set(\"type\", obj.get(\"type\"));\n    }\n\n    return this;\n  }\n\n  set(key: string, value: any): this {\n    if (key in this) {\n      isFunction((this as any)[key]) && (this as any)[key](value);\n    } else {\n      super.set(key, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * Return the itemSchema computed type.\n   * If the type is a function used for recursive model,\n   * the function will be called to get the right type.\n   */\n  getComputedType(): any {\n    return getComputedType(this.#target);\n  }\n\n  getComputedItemType(): any {\n    return this.#itemSchema ? this.#itemSchema.getComputedType() : this.getComputedType();\n  }\n\n  /**\n   * Return the Json type as string\n   */\n  getJsonType(): string | string[] {\n    return this.get(\"type\") || getJsonType(this.getComputedType());\n  }\n\n  getTarget() {\n    return this.#target;\n  }\n\n  /**\n   * Get the symbolic name of the entity\n   */\n  getName() {\n    return this.get(\"name\") || (this.#target ? nameOf(classOf(this.getComputedType())) : \"\");\n  }\n\n  clone() {\n    return new JsonSchema(this);\n  }\n}\n"]}