"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSpec = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const core_1 = require("@tsed/core");
const mapOpenSpec_1 = require("./mapOpenSpec");
const getSpec_1 = require("./getSpec");
const getSpecType_1 = require("./getSpecType");
const mergeSpec_1 = require("./mergeSpec");
const SpecTypes_1 = require("../domain/SpecTypes");
const transformToOS2_1 = require("./transformToOS2");
async function readSpec(path) {
    if (fs_extra_1.default.existsSync(path)) {
        try {
            return await fs_extra_1.default.readJSON(path, { encoding: "utf8" });
        }
        catch (e) { }
    }
    /* istanbul ignore next */
    return {};
}
/**
 * Generate OpenAPI spec from multiple sources (models, files, conf)
 * @param tokens
 * @param options
 */
async function generateSpec({ tokens, ...options }) {
    const { version = "1.0.0", acceptMimes, specPath, specVersion } = options;
    const fileSpec = specPath ? await readSpec(specPath) : {};
    const defaultSpec = (0, mapOpenSpec_1.mapOpenSpec)((0, core_1.getValue)(options, "spec", {}), {
        fileSpec,
        version,
        specVersion,
        acceptMimes
    });
    const specType = (0, getSpecType_1.getSpecTypeFromSpec)(defaultSpec);
    let controllersSpec = (0, getSpec_1.getSpec)(tokens, options);
    const spec = (0, mergeSpec_1.mergeSpec)(defaultSpec, controllersSpec);
    if (specType === SpecTypes_1.SpecTypes.SWAGGER) {
        return (0, transformToOS2_1.transformToOS2)(spec);
    }
    return spec;
}
exports.generateSpec = generateSpec;
//# sourceMappingURL=generateSpec.js.map