{"version":3,"file":"route.js","sourceRoot":"","sources":["../../../../src/decorators/operations/route.ts"],"names":[],"mappings":"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","sourcesContent":["import {DecoratorContext} from \"../../domain/DecoratorContext\";\nimport {mapRouteOptions} from \"../../utils/mapRouteOptions\";\nimport {OperationMethods} from \"../../constants/httpMethods\";\nimport {JsonMethodStore} from \"../../domain/JsonMethodStore\";\n\nexport interface RouteChainedDecorators {\n  <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> | void;\n\n  /**\n   * @param string\n   * @constructor\n   */\n  Path(string: string): this;\n\n  /**\n   * Set the operation method\n   * @param method\n   */\n  Method(method: OperationMethods | string): this;\n\n  /**\n   * Set the operation id\n   * @param id\n   */\n  Id(id: string): this;\n\n  /**\n   * Set the operation id\n   * @param name\n   */\n  Name(name: string): this;\n\n  /**\n   *\n   * @param description\n   */\n  Description(description: string): this;\n\n  /**\n   * Summary\n   * @constructor\n   * @param Summary\n   */\n  Summary(Summary: string): this;\n\n  Use(...args: any[]): this;\n\n  UseAfter(...args: any[]): this;\n\n  UseBefore(...args: any[]): this;\n}\n\nclass RouteDecoratorContext extends DecoratorContext<RouteChainedDecorators> {\n  readonly methods: string[] = [\"name\", \"description\", \"summary\", \"method\", \"id\", \"use\", \"useAfter\", \"useBefore\"];\n  protected declare entity: JsonMethodStore;\n\n  protected beforeInit() {\n    const path: string = this.get(\"path\");\n    const method: string = OperationMethods[this.get(\"method\") as OperationMethods] || OperationMethods.CUSTOM;\n\n    path && this.entity.operation.addOperationPath(method, path);\n  }\n\n  protected onMapKey(key: string, value: any) {\n    switch (key) {\n      case \"name\":\n      case \"id\":\n        this.entity.operation.operationId(value);\n        return;\n      case \"summary\":\n        this.entity.operation.summary(value);\n        return;\n      case \"description\":\n        this.entity.operation.description(value);\n        return;\n      case \"use\":\n        this.entity.use(value);\n        return;\n      case \"useAfter\":\n        this.entity.after(value);\n        return;\n      case \"useBefore\":\n        this.entity.before(value);\n        return;\n    }\n\n    return super.onMapKey(key, value);\n  }\n}\n\n/**\n * Describe a new route with a method and path.\n *\n * ```typescript\n * @Controller('/')\n * export class Ctrl {\n *\n *    @Route('GET', '/')\n *    get() { }\n * }\n *\n * ```\n *\n * @returns {Function}\n * @param method\n * @param path\n * @param args\n * @decorator\n * @operation\n */\nexport function Route(method: string, path: string, ...args: any[]): RouteChainedDecorators;\nexport function Route(...args: any[]): RouteChainedDecorators;\nexport function Route(...args: any[]): RouteChainedDecorators {\n  const routeOptions = mapRouteOptions(args);\n\n  const context = new RouteDecoratorContext(routeOptions);\n\n  return context.build();\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function All(path: string | RegExp | any = \"/\", ...args: any[]) {\n  return Route(...[OperationMethods.ALL, path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Get(path: string | RegExp | any = \"/\", ...args: any[]) {\n  return Route(...[OperationMethods.GET, path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Post(path: string | RegExp | any = \"/\", ...args: any[]) {\n  return Route(...[OperationMethods.POST, path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Put(path: string | RegExp | any = \"/\", ...args: any[]) {\n  return Route(...[OperationMethods.PUT, path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Delete(path: string | RegExp | any = \"/\", ...args: any[]) {\n  return Route(...[OperationMethods.DELETE, path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Head(path: string | RegExp | any = \"/\", ...args: any[]) {\n  return Route(...[OperationMethods.HEAD, path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Patch(path: string | RegExp | any = \"/\", ...args: any[]) {\n  return Route(...[OperationMethods.PATCH, path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Options(path: string | RegExp | any = \"/\", ...args: any[]) {\n  return Route(...[OperationMethods.OPTIONS, path].concat(args));\n}\n"]}