import { cleanObject, toMap } from "@tsed/core";
import { execMapper } from "../registries/JsonSchemaMapperContainer.js";
import { popGenerics } from "../utils/generics.js";
import { JsonMap } from "./JsonMap.js";
import { formatParameterType, isParameterType, JsonParameterTypes } from "./JsonParameterTypes.js";
import { createRefName } from "../utils/ref.js";
export class JsonParameter extends JsonMap {
    nestedGenerics = [];
    groups;
    $schema;
    expression;
    getName() {
        const name = this.get("name");
        if (this.get("in") === "files") {
            return name.split(".")[0];
        }
        return name;
    }
    name(name) {
        this.set("name", name);
        return this;
    }
    examples(examples) {
        super.set("examples", examples);
        return this;
    }
    description(description) {
        this.set("description", description);
        return this;
    }
    in(inType, expression = "") {
        this.set("in", formatParameterType(inType));
        this.expression = expression;
        return this;
    }
    required(required) {
        this.set("required", required);
        return this;
    }
    schema(schema) {
        this.$schema = schema;
        return this;
    }
    toJSON(options = {}) {
        if (!isParameterType(this.get("in"))) {
            return null;
        }
        const schemasContainer = toMap(options.schemas || {});
        return this.build({ ...options, groups: this.groups }, schemasContainer);
    }
    build(options, schemasContainer) {
        const { type, schema, ...parameter } = super.toJSON(options);
        const jsonSchema = execMapper("item", this.$schema, {
            ...options,
            ...popGenerics(this)
        });
        parameter.required = parameter.required || this.get("in") === JsonParameterTypes.PATH;
        switch (this.get("in")) {
            case JsonParameterTypes.FILES:
                return this.getFileSchema(jsonSchema, parameter);
            case JsonParameterTypes.QUERY:
                if (jsonSchema.$ref) {
                    if (!parameter.name) {
                        return this.refToParameters(parameter, options, schemasContainer);
                    }
                    parameter.style = "deepObject";
                }
                break;
        }
        parameter.schema = jsonSchema;
        return parameter;
    }
    getFileSchema(jsonSchema, parameter) {
        const schema = {
            type: "string",
            format: "binary",
            oneOf: undefined
        };
        if (jsonSchema.type === "array") {
            jsonSchema.items = cleanObject({
                ...jsonSchema.items,
                ...schema
            });
            parameter.schema = jsonSchema;
        }
        else {
            parameter.schema = cleanObject({
                ...jsonSchema,
                ...schema
            });
        }
        return parameter;
    }
    refToParameters(parameter, options, schemasContainer) {
        const name = createRefName(this.$schema.getName(), options);
        const schema = options.schemas[name];
        if (options.schemas[name] && !schemasContainer.has(name)) {
            delete options.schemas[this.$schema.getName()];
        }
        return Object.entries(schema.properties || {}).reduce((params, [key, { description, ...prop }]) => {
            return [
                ...params,
                cleanObject({
                    ...parameter,
                    name: key,
                    required: (schema.required || []).includes(key),
                    description,
                    schema: prop,
                    style: prop.$ref ? "deepObject" : undefined
                })
            ];
        }, []);
    }
}
//# sourceMappingURL=JsonParameter.js.map