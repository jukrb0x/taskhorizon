import { cleanObject, isArray, uniqBy } from "@tsed/core";
import { SpecTypes } from "../domain/SpecTypes.js";
import { buildPath } from "./buildPath.js";
import { getJsonEntityStore } from "./getJsonEntityStore.js";
import { getOperationsStores } from "./getOperationsStores.js";
import { mergeOperation } from "./mergeOperation.js";
import { operationIdFormatter } from "./operationIdFormatter.js";
import { mergeSpec } from "./mergeSpec.js";
/**
 * @ignore
 */
const caches = new Map();
/**
 * @ignore
 */
function get(model, options, cb) {
    if (!caches.has(model)) {
        caches.set(model, new Map());
    }
    const cache = caches.get(model);
    const key = JSON.stringify(options);
    if (!cache.has(key)) {
        cache.set(key, cb());
    }
    return cache.get(key);
}
function generate(model, options) {
    const store = getJsonEntityStore(model);
    const { schemas = {}, paths = {}, rootPath = "/", tags = [] } = options;
    const specType = SpecTypes.OPENAPI;
    const ctrlPath = store.path;
    const defaultTags = cleanObject({
        name: store.schema.getName(),
        description: store.schema.get("description")
    });
    const specJson = { paths };
    getOperationsStores(model).forEach((operationStore) => {
        if (operationStore.store.get("hidden")) {
            return;
        }
        const operation = operationStore.operation.toJSON({ ...options, specType, schemas });
        operationStore.operation.operationPaths.forEach(({ path, method }) => {
            if (method) {
                mergeOperation(specJson, operation, {
                    rootPath: buildPath(rootPath + ctrlPath),
                    path,
                    method,
                    defaultTags,
                    tags,
                    specType,
                    operationId: (path) => options.operationIdFormatter(operationStore.parent.schema.get("name") || operationStore.parent.targetName, operationStore.propertyName, path)
                });
            }
        });
    });
    specJson.tags = uniqBy(tags, "name");
    if (Object.keys(schemas).length) {
        specJson.components = {
            schemas
        };
    }
    return specJson;
}
/**
 * Return the swagger or open spec for the given class.
 * @param model
 * @param options
 */
export function getSpec(model, options = {}) {
    options = {
        ...options,
        operationIdFormatter: options.operationIdFormatter || operationIdFormatter(options.operationIdPattern),
        root: false
    };
    if (isArray(model)) {
        let finalSpec = {};
        options = {
            ...options,
            specType: SpecTypes.OPENAPI,
            paths: {},
            tags: [],
            schemas: {},
            append(spec) {
                finalSpec = mergeSpec(finalSpec, spec);
            }
        };
        model.forEach(({ token, ...opts }) => {
            const spec = getSpec(token, {
                ...options,
                ...opts
            });
            options.append(spec);
        });
        return finalSpec;
    }
    return get(model, options, () => generate(model, options));
}
//# sourceMappingURL=getSpec.js.map