"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Options = exports.Patch = exports.Head = exports.Delete = exports.Put = exports.Post = exports.Get = exports.All = exports.Route = void 0;
const DecoratorContext_1 = require("../../domain/DecoratorContext");
const mapRouteOptions_1 = require("../../utils/mapRouteOptions");
const httpMethods_1 = require("../../constants/httpMethods");
class RouteDecoratorContext extends DecoratorContext_1.DecoratorContext {
    methods = ["name", "description", "summary", "method", "id", "use", "useAfter", "useBefore"];
    beforeInit() {
        const path = this.get("path");
        const method = httpMethods_1.OperationMethods[this.get("method")] || httpMethods_1.OperationMethods.CUSTOM;
        path && this.entity.operation.addOperationPath(method, path);
    }
    onMapKey(key, value) {
        switch (key) {
            case "name":
            case "id":
                this.entity.operation.operationId(value);
                return;
            case "summary":
                this.entity.operation.summary(value);
                return;
            case "description":
                this.entity.operation.description(value);
                return;
            case "use":
                this.entity.use(value);
                return;
            case "useAfter":
                this.entity.after(value);
                return;
            case "useBefore":
                this.entity.before(value);
                return;
        }
        return super.onMapKey(key, value);
    }
}
function Route(...args) {
    const routeOptions = (0, mapRouteOptions_1.mapRouteOptions)(args);
    const context = new RouteDecoratorContext(routeOptions);
    return context.build();
}
exports.Route = Route;
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
function All(path = "/", ...args) {
    return Route(...[httpMethods_1.OperationMethods.ALL, path].concat(args));
}
exports.All = All;
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
function Get(path = "/", ...args) {
    return Route(...[httpMethods_1.OperationMethods.GET, path].concat(args));
}
exports.Get = Get;
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
function Post(path = "/", ...args) {
    return Route(...[httpMethods_1.OperationMethods.POST, path].concat(args));
}
exports.Post = Post;
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
function Put(path = "/", ...args) {
    return Route(...[httpMethods_1.OperationMethods.PUT, path].concat(args));
}
exports.Put = Put;
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
function Delete(path = "/", ...args) {
    return Route(...[httpMethods_1.OperationMethods.DELETE, path].concat(args));
}
exports.Delete = Delete;
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
function Head(path = "/", ...args) {
    return Route(...[httpMethods_1.OperationMethods.HEAD, path].concat(args));
}
exports.Head = Head;
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
function Patch(path = "/", ...args) {
    return Route(...[httpMethods_1.OperationMethods.PATCH, path].concat(args));
}
exports.Patch = Patch;
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */
function Options(path = "/", ...args) {
    return Route(...[httpMethods_1.OperationMethods.OPTIONS, path].concat(args));
}
exports.Options = Options;
//# sourceMappingURL=route.js.map