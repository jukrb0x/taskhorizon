"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSpec = void 0;
const core_1 = require("@tsed/core");
const SpecTypes_1 = require("../domain/SpecTypes");
const buildPath_1 = require("./buildPath");
const getJsonEntityStore_1 = require("./getJsonEntityStore");
const getOperationsStores_1 = require("./getOperationsStores");
const mergeOperation_1 = require("./mergeOperation");
const operationIdFormatter_1 = require("./operationIdFormatter");
const mergeSpec_1 = require("./mergeSpec");
/**
 * @ignore
 */
const caches = new Map();
/**
 * @ignore
 */
function get(model, options, cb) {
    if (!caches.has(model)) {
        caches.set(model, new Map());
    }
    const cache = caches.get(model);
    const key = JSON.stringify(options);
    if (!cache.has(key)) {
        cache.set(key, cb());
    }
    return cache.get(key);
}
function generate(model, options) {
    const store = (0, getJsonEntityStore_1.getJsonEntityStore)(model);
    const { schemas = {}, paths = {}, rootPath = "/", tags = [] } = options;
    const specType = SpecTypes_1.SpecTypes.OPENAPI;
    const ctrlPath = store.path;
    const defaultTags = (0, core_1.cleanObject)({
        name: store.schema.getName(),
        description: store.schema.get("description")
    });
    const specJson = { paths };
    (0, getOperationsStores_1.getOperationsStores)(model).forEach((operationStore) => {
        if (operationStore.store.get("hidden")) {
            return;
        }
        const operation = operationStore.operation.toJSON({ ...options, specType, schemas });
        operationStore.operation.operationPaths.forEach(({ path, method }) => {
            if (method) {
                (0, mergeOperation_1.mergeOperation)(specJson, operation, {
                    rootPath: (0, buildPath_1.buildPath)(rootPath + ctrlPath),
                    path,
                    method,
                    defaultTags,
                    tags,
                    specType,
                    operationId: (path) => options.operationIdFormatter(operationStore.parent.schema.get("name") || operationStore.parent.targetName, operationStore.propertyName, path)
                });
            }
        });
    });
    specJson.tags = (0, core_1.uniqBy)(tags, "name");
    if (Object.keys(schemas).length) {
        specJson.components = {
            schemas
        };
    }
    return specJson;
}
/**
 * Return the swagger or open spec for the given class.
 * @param model
 * @param options
 */
function getSpec(model, options = {}) {
    options = {
        ...options,
        operationIdFormatter: options.operationIdFormatter || (0, operationIdFormatter_1.operationIdFormatter)(options.operationIdPattern),
        root: false
    };
    if ((0, core_1.isArray)(model)) {
        let finalSpec = {};
        options = {
            ...options,
            specType: SpecTypes_1.SpecTypes.OPENAPI,
            paths: {},
            tags: [],
            schemas: {},
            append(spec) {
                finalSpec = (0, mergeSpec_1.mergeSpec)(finalSpec, spec);
            }
        };
        model.forEach(({ token, ...opts }) => {
            const spec = getSpec(token, {
                ...options,
                ...opts
            });
            options.append(spec);
        });
        return finalSpec;
    }
    return get(model, options, () => generate(model, options));
}
exports.getSpec = getSpec;
//# sourceMappingURL=getSpec.js.map