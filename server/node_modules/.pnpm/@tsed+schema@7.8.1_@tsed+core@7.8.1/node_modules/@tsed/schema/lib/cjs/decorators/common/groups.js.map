{"version":3,"file":"groups.js","sourceRoot":"","sources":["../../../../src/decorators/common/groups.ts"],"names":[],"mappings":";;;AAAA,qCAA0C;AAG1C,yDAAoD;AACpD,iDAA4C;AAE5C;;GAEG;AACH,SAAS,WAAW,CAAC,MAAW,EAAE,MAAsB;IACtD,MAAM,OAAO,GAAyB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAEhE,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;QACrC,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC;QAC1G,MAAM,SAAS,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;QAEpC,SAAS,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,WAAW,CAAC,CAAC;IACvD,CAAC,CAAC,CAAC;AACL,CAAC;AAaD,SAAgB,MAAM,CAAC,GAAG,MAAW;IACnC,OAAO,IAAA,2BAAY,EAAC,CAAC,MAAM,EAAE,EAAE;QAC7B,QAAQ,MAAM,CAAC,aAAa,EAAE;YAC5B,KAAK,qBAAc,CAAC,KAAK;gBACvB,WAAW,CAAC,MAAM,EAAE,MAAwB,CAAC,CAAC;gBAC9C,MAAM;YACR,KAAK,qBAAc,CAAC,IAAI;gBACtB,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAa,EAAE,WAAqB,EAAE,EAAE;oBACzE,IAAI,CAAC,IAAI,EAAE;wBACT,IAAI,IAAA,yBAAW,EAAC,MAAM,EAAE,WAAW,CAAC,EAAE;4BACpC,OAAO,IAAI,CAAC;yBACb;qBACF;oBAED,OAAO,IAAI,CAAC;gBACd,CAAC,CAAC,CAAC;gBACH,MAAM;YACR,KAAK,qBAAc,CAAC,KAAK;gBACtB,MAA6B,CAAC,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC;gBACzD,MAAM;SACT;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAtBD,wBAsBC","sourcesContent":["import {DecoratorTypes} from \"@tsed/core\";\nimport type {JsonClassStore} from \"../../domain/JsonClassStore\";\nimport type {JsonParameterStore} from \"../../domain/JsonParameterStore\";\nimport {matchGroups} from \"../../utils/matchGroups\";\nimport {JsonEntityFn} from \"./jsonEntityFn\";\n\n/**\n * @ignore\n */\nfunction groupsClass(groups: any, entity: JsonClassStore) {\n  const entries: [string, string[]][] = Object.entries(groups[0]);\n\n  entity.children.forEach((propEntity) => {\n    const groups = entries.filter(([, props]) => props.includes(propEntity.propertyName)).map(([key]) => key);\n    const decorator = Groups(...groups);\n\n    decorator(propEntity.target, propEntity.propertyKey);\n  });\n}\n\n/**\n * Apply groups validation strategy\n *\n * @decorator\n * @validation\n * @swagger\n * @schema\n * @input\n */\nexport function Groups<T>(groupsDefinition: Record<string, (keyof T)[]>): ClassDecorator;\nexport function Groups(...groups: string[]): Function;\nexport function Groups(...groups: any): any {\n  return JsonEntityFn((entity) => {\n    switch (entity.decoratorType) {\n      case DecoratorTypes.CLASS:\n        groupsClass(groups, entity as JsonClassStore);\n        break;\n      case DecoratorTypes.PROP:\n        entity.schema.$hooks.on(\"groups\", (prev: boolean, givenGroups: string[]) => {\n          if (!prev) {\n            if (matchGroups(groups, givenGroups)) {\n              return true;\n            }\n          }\n\n          return prev;\n        });\n        break;\n      case DecoratorTypes.PARAM:\n        (entity as JsonParameterStore).parameter.groups = groups;\n        break;\n    }\n  });\n}\n"]}