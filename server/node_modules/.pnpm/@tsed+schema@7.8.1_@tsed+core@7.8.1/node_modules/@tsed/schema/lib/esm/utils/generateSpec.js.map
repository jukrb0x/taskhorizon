{"version":3,"file":"generateSpec.js","sourceRoot":"","sources":["../../../src/utils/generateSpec.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,UAAU,CAAC;AAC1B,OAAO,EAAC,QAAQ,EAAC,MAAM,YAAY,CAAC;AAEpC,OAAO,EAAC,WAAW,EAAC,MAAM,eAAe,CAAC;AAC1C,OAAO,EAAC,OAAO,EAA0C,MAAM,WAAW,CAAC;AAC3E,OAAO,EAAC,mBAAmB,EAAC,MAAM,eAAe,CAAC;AAClD,OAAO,EAAC,SAAS,EAAC,MAAM,aAAa,CAAC;AACtC,OAAO,EAAC,SAAS,EAAC,MAAM,qBAAqB,CAAC;AAC9C,OAAO,EAAC,cAAc,EAAC,MAAM,kBAAkB,CAAC;AAWhD,KAAK,UAAU,QAAQ,CAAC,IAAY;IAClC,IAAI,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;QACvB,IAAI;YACF,OAAO,MAAM,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAC,QAAQ,EAAE,MAAM,EAAC,CAAC,CAAC;SACpD;QAAC,OAAO,CAAC,EAAE,GAAE;KACf;IAED,0BAA0B;IAC1B,OAAO,EAAE,CAAC;AACZ,CAAC;AAED;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,YAAY,CAAC,EAAC,MAAM,EAAE,GAAG,OAAO,EAAsB;IAC1E,MAAM,EAAC,OAAO,GAAG,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAE,WAAW,EAAC,GAAG,OAAO,CAAC;IACxE,MAAM,QAAQ,GAAmC,QAAQ,CAAC,CAAC,CAAC,MAAM,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAE1F,MAAM,WAAW,GAAG,WAAW,CAAC,QAAQ,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CAAC,EAAE;QAC7D,QAAQ;QACR,OAAO;QACP,WAAW;QACX,WAAW;KACZ,CAAC,CAAC;IAEH,MAAM,QAAQ,GAAG,mBAAmB,CAAC,WAAW,CAAC,CAAC;IAElD,IAAI,eAAe,GAAQ,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IACpD,MAAM,IAAI,GAAQ,SAAS,CAAC,WAAW,EAAE,eAAe,CAAC,CAAC;IAE1D,IAAI,QAAQ,KAAK,SAAS,CAAC,OAAO,EAAE;QAClC,OAAO,cAAc,CAAC,IAAI,CAAQ,CAAC;KACpC;IAED,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["import fs from \"fs-extra\";\nimport {getValue} from \"@tsed/core\";\nimport {OpenSpec2, OpenSpec3} from \"@tsed/openspec\";\nimport {mapOpenSpec} from \"./mapOpenSpec\";\nimport {getSpec, JsonTokenOptions, SpecSerializerOptions} from \"./getSpec\";\nimport {getSpecTypeFromSpec} from \"./getSpecType\";\nimport {mergeSpec} from \"./mergeSpec\";\nimport {SpecTypes} from \"../domain/SpecTypes\";\nimport {transformToOS2} from \"./transformToOS2\";\n\nexport interface GenerateSpecOptions extends Omit<SpecSerializerOptions, \"specType\"> {\n  tokens: JsonTokenOptions;\n  version?: string;\n  acceptMimes?: string;\n  specPath?: string;\n  specVersion?: string;\n  spec?: any;\n}\n\nasync function readSpec(path: string) {\n  if (fs.existsSync(path)) {\n    try {\n      return await fs.readJSON(path, {encoding: \"utf8\"});\n    } catch (e) {}\n  }\n\n  /* istanbul ignore next */\n  return {};\n}\n\n/**\n * Generate OpenAPI spec from multiple sources (models, files, conf)\n * @param tokens\n * @param options\n */\nexport async function generateSpec({tokens, ...options}: GenerateSpecOptions): Promise<OpenSpec2 | OpenSpec3> {\n  const {version = \"1.0.0\", acceptMimes, specPath, specVersion} = options;\n  const fileSpec: Partial<OpenSpec2 | OpenSpec3> = specPath ? await readSpec(specPath) : {};\n\n  const defaultSpec = mapOpenSpec(getValue(options, \"spec\", {}), {\n    fileSpec,\n    version,\n    specVersion,\n    acceptMimes\n  });\n\n  const specType = getSpecTypeFromSpec(defaultSpec);\n\n  let controllersSpec: any = getSpec(tokens, options);\n  const spec: any = mergeSpec(defaultSpec, controllersSpec);\n\n  if (specType === SpecTypes.SWAGGER) {\n    return transformToOS2(spec) as any;\n  }\n\n  return spec;\n}\n"]}