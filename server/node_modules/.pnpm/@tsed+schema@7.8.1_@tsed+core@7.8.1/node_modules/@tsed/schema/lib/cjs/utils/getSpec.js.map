{"version":3,"file":"getSpec.js","sourceRoot":"","sources":["../../../src/utils/getSpec.ts"],"names":[],"mappings":"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","sourcesContent":["import {cleanObject, isArray, Type, uniqBy} from \"@tsed/core\";\nimport {OpenSpec3} from \"@tsed/openspec\";\nimport {SpecTypes} from \"../domain/SpecTypes\";\nimport {JsonSchemaOptions} from \"../interfaces/JsonSchemaOptions\";\nimport {buildPath} from \"./buildPath\";\nimport {getJsonEntityStore} from \"./getJsonEntityStore\";\nimport {getOperationsStores} from \"./getOperationsStores\";\nimport {mergeOperation} from \"./mergeOperation\";\nimport {operationIdFormatter} from \"./operationIdFormatter\";\nimport {mergeSpec} from \"./mergeSpec\";\n\nexport type JsonTokenOptions = ({token: Type<any>} & Partial<SpecSerializerOptions>)[];\n\nexport interface SpecSerializerOptions extends JsonSchemaOptions {\n  /**\n   * Paths\n   */\n  paths?: any;\n  /**\n   * Root path. This paths will be added to all generated paths Object.\n   */\n  rootPath?: string;\n  /**\n   * A function to generate the operationId.\n   */\n  operationIdFormatter?: (name: string, propertyKey: string, path: string) => string;\n  /**\n   * A pattern to generate the operationId.\n   */\n  operationIdPattern?: string;\n}\n\n/**\n * @ignore\n */\nconst caches: Map<Type<any>, Map<string, any>> = new Map();\n\n/**\n * @ignore\n */\nfunction get(model: Type<any>, options: any, cb: any) {\n  if (!caches.has(model)) {\n    caches.set(model, new Map());\n  }\n\n  const cache = caches.get(model)!;\n  const key = JSON.stringify(options);\n\n  if (!cache.has(key)) {\n    cache.set(key, cb());\n  }\n\n  return cache.get(key);\n}\n\nfunction generate(model: Type<any>, options: SpecSerializerOptions) {\n  const store = getJsonEntityStore(model);\n  const {schemas = {}, paths = {}, rootPath = \"/\", tags = []} = options;\n  const specType = SpecTypes.OPENAPI;\n  const ctrlPath = store.path;\n  const defaultTags = cleanObject({\n    name: store.schema.getName(),\n    description: store.schema.get(\"description\")\n  });\n\n  const specJson: any = {paths};\n\n  getOperationsStores(model).forEach((operationStore) => {\n    if (operationStore.store.get(\"hidden\")) {\n      return;\n    }\n\n    const operation = operationStore.operation!.toJSON({...options, specType, schemas});\n\n    operationStore.operation!.operationPaths.forEach(({path, method}: {path: string; method: string}) => {\n      if (method) {\n        mergeOperation(specJson, operation, {\n          rootPath: buildPath(rootPath + ctrlPath),\n          path,\n          method,\n          defaultTags,\n          tags,\n          specType,\n          operationId: (path: string) =>\n            options.operationIdFormatter!(\n              operationStore.parent.schema.get(\"name\") || operationStore.parent.targetName,\n              operationStore.propertyName,\n              path\n            )\n        });\n      }\n    });\n  });\n\n  specJson.tags = uniqBy(tags, \"name\");\n\n  if (Object.keys(schemas).length) {\n    specJson.components = {\n      schemas\n    };\n  }\n\n  return specJson;\n}\n\n/**\n * Return the swagger or open spec for the given class.\n * @param model\n * @param options\n */\nexport function getSpec(model: Type<any> | JsonTokenOptions, options: SpecSerializerOptions = {}): Partial<OpenSpec3> {\n  options = {\n    ...options,\n    operationIdFormatter: options.operationIdFormatter || operationIdFormatter(options.operationIdPattern),\n    root: false\n  };\n\n  if (isArray(model)) {\n    let finalSpec: any = {};\n\n    options = {\n      ...options,\n      specType: SpecTypes.OPENAPI,\n      paths: {},\n      tags: [],\n      schemas: {},\n      append(spec: any) {\n        finalSpec = mergeSpec(finalSpec, spec);\n      }\n    };\n\n    model.forEach(({token, ...opts}) => {\n      const spec = getSpec(token, {\n        ...options,\n        ...opts\n      });\n\n      options.append(spec);\n    });\n\n    return finalSpec;\n  }\n\n  return get(model, options, () => generate(model, options));\n}\n"]}