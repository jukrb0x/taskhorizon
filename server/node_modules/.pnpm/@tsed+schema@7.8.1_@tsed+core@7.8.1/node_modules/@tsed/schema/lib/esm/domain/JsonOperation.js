import { deepMerge, uniq, uniqBy } from "@tsed/core";
import { getStatusMessage } from "../constants/httpStatusMessages.js";
import { isRedirectionStatus, isSuccessStatus } from "../utils/isSuccessStatus.js";
import { JsonMap } from "./JsonMap.js";
import { isParameterType, JsonParameterTypes } from "./JsonParameterTypes.js";
import { JsonRequestBody } from "./JsonRequestBody.js";
import { JsonResponse } from "./JsonResponse.js";
import { JsonSchema } from "./JsonSchema.js";
export class JsonOperation extends JsonMap {
    operationPaths = new Map();
    #status;
    #redirection = false;
    constructor(obj = {}) {
        super({ parameters: [], responses: new JsonMap(), ...obj });
    }
    get response() {
        return this.getResponses().get(this.getStatus().toString());
    }
    get status() {
        return this.#status;
    }
    tags(tags) {
        super.set("tags", tags);
        return this;
    }
    addTags(tags) {
        tags = uniqBy([...(this.get("tags") || []), ...tags], "name");
        return this.tags(tags);
    }
    summary(summary) {
        super.set("summary", summary);
        return this;
    }
    operationId(operationId) {
        this.set("operationId", operationId);
        return this;
    }
    responses(responses) {
        this.set("responses", responses);
        return this;
    }
    defaultStatus(status) {
        this.#status = status;
        return this;
    }
    getStatus() {
        return this.#status || 200;
    }
    setRedirection(status = 302) {
        this.#redirection = true;
        this.#status = status;
        return this;
    }
    isRedirection(status) {
        if (this.#redirection) {
            if (status) {
                return isRedirectionStatus(status);
            }
        }
        return this.#redirection;
    }
    addResponse(statusCode, response) {
        if ((isSuccessStatus(statusCode) || isRedirectionStatus(statusCode)) && !this.#status) {
            const res = this.getResponseOf(200);
            this.getResponses().set(statusCode.toString(), res).delete("200");
            this.defaultStatus(Number(statusCode));
        }
        const currentCode = statusCode === "default" ? this.getStatus().toString() : statusCode.toString();
        const currentResponse = this.getResponses().get(currentCode);
        if (!currentResponse) {
            response.status = Number(currentCode);
            this.getResponses().set(currentCode, response);
        }
        else {
            response.forEach((value, key) => {
                if (!["content"].includes(key)) {
                    currentResponse.set(key, deepMerge(currentResponse.get(key), value));
                }
            });
            currentResponse.status = Number(currentCode);
        }
        return this;
    }
    getResponses() {
        return this.get("responses");
    }
    getResponseOf(status) {
        return (status === "default" ? this.response : this.getResponses().get(String(status))) || new JsonResponse();
    }
    ensureResponseOf(status) {
        this.addResponse(status, this.getResponseOf(status));
        return this.getResponseOf(status);
    }
    getHeadersOf(status) {
        return this.getResponseOf(status).get("headers") || {};
    }
    getContentTypeOf(status) {
        return [...this.getResponseOf(status).get("content").keys()].slice(-1)[0];
    }
    security(security) {
        this.set("security", security);
        return this;
    }
    addSecurityScopes(name, scopes) {
        const security = this.get("security") || {};
        security[name] = uniq([...(security[name] || []), ...scopes]);
        return this.security(security);
    }
    description(description) {
        super.set("description", description);
        return this;
    }
    deprecated(deprecated) {
        super.set("deprecated", deprecated);
        return this;
    }
    parameters(parameters) {
        super.set("parameters", parameters);
        return this;
    }
    addParameter(index, parameter) {
        if (index === -1) {
            index = this.get("parameters").length;
        }
        this.get("parameters")[index] = parameter;
    }
    consumes(consumes) {
        super.set("consumes", consumes);
        return this;
    }
    produces(produces) {
        super.set("produces", produces);
        return this;
    }
    addProduce(produce) {
        const produces = uniq([].concat(this.get("produces"), produce)).filter(Boolean);
        this.set("produces", produces);
    }
    addOperationPath(method, path, options = {}) {
        this.operationPaths.set(String(method) + String(path), {
            ...options,
            method,
            path
        });
        return this;
    }
    toJSON(options = {}) {
        const operation = super.toJSON({ ...options, ignore: ["parameters"] });
        const bodyParameters = [];
        const parameters = [];
        if (operation.security) {
            operation.security = [].concat(operation.security);
        }
        this.get("parameters").forEach((parameter) => {
            if (!isParameterType(this.get("in"))) {
                if (parameter.get("in")) {
                    if ([JsonParameterTypes.BODY, JsonParameterTypes.FILES].includes(parameter.get("in"))) {
                        bodyParameters.push(parameter);
                    }
                    else {
                        parameters.push(...[].concat(parameter.toJSON(options)));
                    }
                }
            }
        });
        operation.parameters = parameters.filter(Boolean);
        if (this.get("responses").size === 0) {
            operation.responses = {
                "200": {
                    description: getStatusMessage(200)
                }
            };
        }
        if (bodyParameters.length) {
            const parameter = buildSchemaFromBodyParameters(bodyParameters, options);
            operation.requestBody = toRequestBody(this, parameter).toJSON(options);
        }
        delete operation.consumes;
        delete operation.produces;
        return operation;
    }
}
function toRequestBody(operation, { schema, examples, in: _, ...props }) {
    const requestBody = new JsonRequestBody(props);
    const consumes = operation.get("consumes")?.length ? operation.get("consumes") : ["application/json"];
    consumes.forEach((consume) => {
        requestBody.addContent(consume, schema, examples);
    });
    return requestBody;
}
function buildSchemaFromBodyParameters(parameters, options) {
    let schema = new JsonSchema();
    const props = {};
    const refs = [];
    let propsLength = 0;
    parameters.forEach((parameter) => {
        const name = parameter.getName();
        Array.from(parameter.entries())
            .filter(([key]) => !["in", "name"].includes(key))
            .forEach(([key, value]) => {
            if (props[key] === undefined) {
                props[key] = value;
            }
        });
        const jsonParameter = parameter.toJSON(options);
        if (name) {
            schema.addProperty(name, jsonParameter.schema || {
                type: jsonParameter.type
            });
            if (parameter.get("required")) {
                schema.addRequired(name);
            }
            propsLength++;
        }
        else {
            refs.push(jsonParameter);
        }
    });
    if (!propsLength) {
        if (refs.length === 1) {
            return refs[0];
        }
    }
    schema.type("object");
    return { schema: schema.toJSON(options), required: false, ...props };
}
//# sourceMappingURL=JsonOperation.js.map