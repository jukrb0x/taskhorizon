"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserialize = exports.plainObjectToClass = void 0;
const core_1 = require("@tsed/core");
const schema_1 = require("@tsed/schema");
require("../components/ArrayMapper");
require("../components/DateMapper");
require("../components/MapMapper");
require("../components/PrimitiveMapper");
require("../components/SetMapper");
require("../components/SymbolMapper");
const JsonMapperContext_1 = require("../domain/JsonMapperContext");
const JsonMapperSettings_1 = require("../domain/JsonMapperSettings");
const JsonMapperTypesContainer_1 = require("../domain/JsonMapperTypesContainer");
const alterAfterDeserialize_1 = require("../hooks/alterAfterDeserialize");
const alterBeforeDeserialize_1 = require("../hooks/alterBeforeDeserialize");
function isDeserializable(obj, options) {
    if ((!!options.collectionType && (0, core_1.isNil)(obj)) || obj === undefined) {
        return false;
    }
    return !((0, core_1.isEmpty)(options.type) || (options.type === Object && !options.collectionType));
}
function alterValue(schema, value, options) {
    return schema.$hooks.alter("onDeserialize", value, [options]);
}
function transformCollection(src, options) {
    const { types, type = Object, collectionType } = options;
    const context = new JsonMapperContext_1.JsonMapperContext({
        type,
        collectionType,
        options,
        next: (data, { collectionType, ...options }) => deserialize(data, options)
    });
    return types?.get(options.collectionType)?.deserialize(src, context);
}
function transformType(src, options) {
    const { types, type = Object } = options;
    const context = new JsonMapperContext_1.JsonMapperContext({
        type,
        options,
        next: (data, { type, ...options }) => deserialize(data, options)
    });
    return types?.get(type)?.deserialize(src, context);
}
function getAdditionalProperties(nbProps, store, options) {
    const additionalProperties = store.schema.get("additionalProperties");
    if ((0, core_1.isBoolean)(additionalProperties) || (0, core_1.isClass)(additionalProperties)) {
        return additionalProperties;
    }
    return nbProps === 0 || !!options.additionalProperties;
}
/**
 * Transform given plain object to class.
 * @param src
 * @param options
 */
function plainObjectToClass(src, options) {
    if ((0, core_1.isEmpty)(src)) {
        return src;
    }
    const { type, store = schema_1.JsonEntityStore.from(type) } = options;
    const propertiesMap = (0, schema_1.getProperties)(store, { ...options, withIgnoredProps: true });
    let keys = new Set((0, core_1.objectKeys)(src));
    const additionalProperties = getAdditionalProperties(propertiesMap.size, store, options);
    src = (0, alterBeforeDeserialize_1.alterBeforeDeserialize)(src, store.schema, options);
    const out = new type(options.disableUnsecureConstructor ? {} : src);
    propertiesMap.forEach((propStore) => {
        const key = options.useAlias
            ? propStore.parent.schema.getAliasOf(propStore.propertyName) || propStore.propertyName
            : propStore.propertyName;
        keys.delete(key);
        if ((0, schema_1.alterIgnore)(propStore.schema, options)) {
            return;
        }
        let value = alterValue(propStore.schema, src[key], { ...options, self: src });
        value =
            value === src[key]
                ? deserialize(value, {
                    ...options,
                    store: propStore,
                    self: src,
                    collectionType: propStore.collectionType
                })
                : value;
        if (!propStore.isGetterOnly()) {
            if (value !== undefined) {
                out[propStore.propertyName] = value;
            }
            else if (options.partial) {
                delete out[propStore.propertyName];
            }
        }
    });
    if (additionalProperties) {
        if ((0, core_1.isBoolean)(additionalProperties)) {
            keys.forEach((key) => {
                out[key] = src[key];
            });
        }
        else {
            const type = additionalProperties.getComputedType();
            keys.forEach((key) => {
                out[key] = deserialize(src[key], {
                    ...options,
                    type
                });
            });
        }
    }
    return (0, alterAfterDeserialize_1.alterAfterDeserialize)(out, store.schema, options);
}
exports.plainObjectToClass = plainObjectToClass;
function mapPropStoreOptions(store, options) {
    const itemOpts = {
        ...options,
        store: undefined,
        type: store.computedType
    };
    if (store.schema.isDiscriminator) {
        itemOpts.type = store.schema.discriminator();
    }
    if (store.schema.hasGenerics) {
        itemOpts.nestedGenerics = store.schema.nestedGenerics;
    }
    else if (store.schema.isGeneric && options.nestedGenerics) {
        const [genericTypes = [], ...nestedGenerics] = options.nestedGenerics;
        const genericLabels = store.parent.schema.genericLabels || [];
        itemOpts.type = genericTypes[genericLabels.indexOf(store.schema.genericType)] || Object;
        if (itemOpts.type instanceof schema_1.JsonSchema) {
            itemOpts.type = itemOpts.type.getTarget();
        }
        itemOpts.nestedGenerics = nestedGenerics;
    }
    return itemOpts;
}
function mapParamStoreOptions(store, options) {
    return {
        ...options,
        store: undefined,
        type: store.itemSchema.isDiscriminator ? store.itemSchema.discriminator() : store.type,
        collectionType: store.collectionType,
        groups: store.parameter.groups,
        genericTypes: store.nestedGenerics[0],
        nestedGenerics: store.nestedGenerics
    };
}
function buildOptions(options) {
    if (options.store instanceof schema_1.JsonPropertyStore) {
        return buildOptions(mapPropStoreOptions(options.store, options));
    }
    if (options.store instanceof schema_1.JsonParameterStore) {
        return buildOptions(mapParamStoreOptions(options.store, options));
    }
    if (options.store instanceof schema_1.JsonEntityStore) {
        options.type = options.store.computedType;
        options.collectionType = options.store.collectionType;
        options.store = undefined;
    }
    else if ((0, core_1.isClass)(options.type)) {
        const store = schema_1.JsonEntityStore.from(options.type);
        if (store.schema.isDiscriminator) {
            options.type = schema_1.JsonEntityStore.from(options.type).schema.discriminator();
        }
    }
    return {
        groups: false,
        useAlias: true,
        ...options,
        additionalProperties: (0, core_1.getValue)(options, "additionalProperties", JsonMapperSettings_1.JsonMapperSettings.additionalProperties),
        disableUnsecureConstructor: (0, core_1.getValue)(options, "disableUnsecureConstructor", JsonMapperSettings_1.JsonMapperSettings.disableUnsecureConstructor),
        partial: options.groups ? options.groups.includes("partial") : false,
        type: options.type ? options.type : undefined,
        types: options.types ? options.types : (0, JsonMapperTypesContainer_1.getJsonMapperTypes)()
    };
}
/**
 * Transform given source to class base on the given `options.type`.
 *
 * @param src
 * @param options
 */
function deserialize(src, options = {}) {
    options = buildOptions(options);
    if (!isDeserializable(src, options)) {
        return src;
    }
    if (!options.collectionType && (0, core_1.isArray)(src)) {
        options.collectionType = Array;
    }
    if (options.collectionType) {
        if (!options.types?.has(options.collectionType)) {
            throw new Error(`${(0, core_1.nameOf)(options.collectionType)} is not supported by JsonMapper.`);
        }
        return transformCollection(src, options);
    }
    if (options.types?.has(options.type)) {
        return transformType(src, options);
    }
    if (options.type instanceof schema_1.Discriminator) {
        const discriminator = options.type;
        const discriminatorValue = src[discriminator.propertyName];
        const type = discriminator.getType(discriminatorValue);
        return plainObjectToClass(src, { ...options, type });
    }
    // class converter
    return plainObjectToClass(src, options);
}
exports.deserialize = deserialize;
//# sourceMappingURL=deserialize.js.map