"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serialize = exports.classToPlainObject = void 0;
const core_1 = require("@tsed/core");
const schema_1 = require("@tsed/schema");
require("../components/ArrayMapper");
require("../components/DateMapper");
require("../components/MapMapper");
require("../components/PrimitiveMapper");
require("../components/SetMapper");
require("../components/SymbolMapper");
const JsonMapperContext_1 = require("../domain/JsonMapperContext");
const JsonMapperTypesContainer_1 = require("../domain/JsonMapperTypesContainer");
function alterValue(schema, value, options) {
    return schema.$hooks.alter("onSerialize", value, [options]);
}
function getSchemaProperties(storedJson, obj) {
    const stores = Array.from((0, schema_1.getPropertiesStores)(storedJson).entries());
    if (!stores.length) {
        // fallback to auto discovering field from obj
        (0, core_1.objectKeys)(obj).forEach((key) => {
            const propStore = schema_1.JsonEntityStore.from(storedJson.target, key);
            stores.push([key, propStore]);
        });
    }
    return stores;
}
function getObjectProperties(obj) {
    return Object.entries(obj).filter(([, value]) => !(0, core_1.isFunction)(value));
}
function getType(propStore, value) {
    if ((0, core_1.isNil)(value) || propStore.type === Object || (0, core_1.isCollection)(propStore.type)) {
        return undefined;
    }
    return propStore.type;
}
function classToPlainObject(obj, options) {
    const { useAlias = true, type, ...props } = options;
    const entity = schema_1.JsonEntityStore.from(type || obj);
    const additionalProperties = !!entity.schema.get("additionalProperties");
    const schemaProperties = getSchemaProperties(entity, obj);
    const properties = new Set();
    const out = schemaProperties.reduce((newObj, [key, propStore]) => {
        properties.add(key);
        const schema = propStore.schema;
        if ((0, schema_1.alterIgnore)(schema, { useAlias, ...props, self: obj })) {
            return newObj;
        }
        let value = alterValue(schema, obj[key], { useAlias, ...props, self: obj });
        value = serialize(value, {
            useAlias,
            self: obj,
            type: value === obj[key] ? getType(propStore, value) : undefined,
            collectionType: propStore.collectionType,
            ...props
        });
        if (value === undefined) {
            return newObj;
        }
        key = useAlias ? propStore.parent.schema.getAliasOf(key) || key : key;
        return {
            ...newObj,
            [key]: value
        };
    }, {});
    if (entity.discriminatorAncestor) {
        const discriminator = entity.discriminatorAncestor.schema.discriminator();
        if (!out[discriminator.propertyName]) {
            out[discriminator.propertyName] = discriminator.getDefaultValue(entity.target);
        }
    }
    if (additionalProperties) {
        (0, core_1.objectKeys)(obj).forEach((key) => {
            if (!properties.has(key)) {
                out[key] = obj[key];
            }
        });
    }
    return out;
}
exports.classToPlainObject = classToPlainObject;
function toObject(obj, options) {
    return getObjectProperties(obj).reduce((newObj, [key, value]) => ({
        ...newObj,
        [key]: serialize(value, options)
    }), {});
}
function getBestType(type, obj) {
    const dataType = (0, core_1.classOf)(obj);
    if (dataType && !(0, core_1.isClassObject)(dataType)) {
        return dataType;
    }
    return type || Object;
}
function hasJsonMethod(obj) {
    return typeof obj.toJSON === "function";
}
function isMongooseObject(obj) {
    return (hasJsonMethod(obj) && obj.$isMongooseModelPrototype) || obj._bsontype;
}
function isMomentObject(obj) {
    return obj && obj?._isAMomentObject;
}
function serialize(obj, { type, collectionType, groups = false, ...options } = {}) {
    if ((0, core_1.isEmpty)(obj)) {
        return obj;
    }
    let currentType = type;
    const types = options.types ? options.types : (0, JsonMapperTypesContainer_1.getJsonMapperTypes)();
    options.groups = groups;
    // FIX custom serialization function from @tsed/mongoose and bson
    if (isMongooseObject(obj)) {
        return obj.toJSON(options);
    }
    if (hasJsonMethod(obj) && !isMomentObject(obj) && !(0, core_1.isDate)(obj)) {
        return serialize(obj.toJSON(), { ...options, type: (0, core_1.classOf)(obj) });
    }
    if (!(0, core_1.isCollection)(obj)) {
        options.type = currentType = getBestType(currentType, obj);
    }
    else if (!options.collectionType) {
        currentType = (0, core_1.classOf)(obj);
        options.type = type;
        options.collectionType = currentType;
    }
    const context = new JsonMapperContext_1.JsonMapperContext({
        type: currentType,
        options,
        next: (data) => serialize(data, {
            ...options,
            collectionType: undefined,
            type: options.type
        })
    });
    const mapper = types.get(currentType) || types.get((0, core_1.nameOf)(currentType));
    if (mapper) {
        const jsonMapper = mapper;
        return jsonMapper.serialize(obj, context);
    }
    else if (obj?._isAMomentObject) {
        return obj.toJSON();
    }
    if ((0, core_1.isArray)(obj)) {
        // Serialize Array class like
        return types.get(Array)?.serialize(obj, context);
    }
    return !(0, core_1.isClassObject)(currentType) ? classToPlainObject(obj, options) : toObject(obj, options);
}
exports.serialize = serialize;
//# sourceMappingURL=serialize.js.map