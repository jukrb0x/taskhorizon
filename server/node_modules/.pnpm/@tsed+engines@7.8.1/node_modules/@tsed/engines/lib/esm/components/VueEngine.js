import { __decorate } from "tslib";
import { Engine } from "./Engine.js";
import { ViewEngine } from "../decorators/viewEngine.js";
import { getCachedEngine, importEngine } from "../utils/cache.js";
import { join, resolve } from "path";
import { promisify } from "util";
function requireFromString(src, filename) {
    const Module = module.constructor;
    const m = new Module();
    m._compile(src, filename);
    return m.exports;
}
/**
 *  simple hash a string
 *  https://stackoverflow.com/a/34842797/493756
 */
function hashCode(str) {
    return str.split("").reduce((prevHash, currVal) => (prevHash << 5) - prevHash + currVal.charCodeAt(0), 0);
}
let VueEngine = class VueEngine extends Engine {
    #renderToString;
    async $onInit() {
        await super.$onInit();
        await importEngine("vue-pronto/lib/index", "pronto");
        await importEngine("vueify");
        await importEngine("vue-server-renderer");
        const ssrRenderer = this.vueServerRenderer.createRenderer();
        this.#renderToString = promisify(ssrRenderer.renderToString.bind(this));
    }
    get pronto() {
        return getCachedEngine("pronto");
    }
    get vueify() {
        return getCachedEngine("vueify");
    }
    get vueServerRenderer() {
        return getCachedEngine("vue-server-renderer");
    }
    $cacheOptions(template, options, fromFile) {
        const fullPath = join(__dirname, `/${hashCode(template)}`);
        if (!fromFile) {
            return {
                ...options,
                filename: fullPath
            };
        }
        return options;
    }
    $compile(template, options) {
        // make up a fake path
        const fullPath = join(__dirname, `/${hashCode(template)}`);
        const promise = this.getComponent(fullPath, template, options);
        return async (options) => {
            return this.renderComponent(await promise, options);
        };
    }
    async $compileFile(file, options) {
        // prontoRenderer assume that the filepath is relative to a passed "rootpath"
        // and if you don't pass a rootpath it will try to find one
        // based on its current __dirname
        // https://github.com/express-vue/vue-pronto/blob/c88e380fee8656bc3ed21c7d3adb2ef331be07d5/lib/utils/findPaths.js#L10-L18
        const fullPath = resolve(file);
        const rootPath = process.cwd();
        const filepath = fullPath.replace(`${rootPath}/`, "");
        const prontoOptions = {
            rootPath,
            vueVersion: { disabled: true }
        };
        if (!options.cache) {
            // disable pronto lru cache
            prontoOptions.cacheOptions = { max: 0 };
        }
        let prontoRenderer = new this.pronto.ProntoVueify(prontoOptions);
        if (!options.cache) {
            // disable pronto internal cache
            // yup
            prontoRenderer.internalCache = {
                get: () => { },
                set: () => { }
            };
        }
        else {
            // so, this ties each "renderer" to a rootPath
            // so I have to create a new prontoRenderer each time
            // which sucks! because I loose the internal cache of it,
            // unless, I keep tabs on both lru and internal caches and replace them every time.
            const internalCache = prontoRenderer.internalCache;
            prontoRenderer.internalCache = {
                get: internalCache.get.bind(internalCache),
                set(filename, component) {
                    internalCache.set(filename, {
                        ...component,
                        data: component.data || (() => options)
                    });
                }
            };
        }
        return (options) => {
            return prontoRenderer.RenderToString(filepath, {}, {
                propsData: options
            });
        };
    }
    async getComponent(fullPath, template, options) {
        // assume that the str the content of a <template> ... </template>
        if (/<template/.test(template.trim())) {
            // assume that the str is a fileContent of a .vue file
            const compile = promisify(this.vueify.compiler.compile.bind(this.vueify.compiler));
            const cmp = await compile(template, fullPath);
            return requireFromString(cmp, fullPath);
        }
        return {
            template,
            data() {
                return options;
            }
        };
    }
    async renderComponent(Component, options) {
        let Factory = this.engine.extend(Component);
        let instance = new Factory({ propsData: options });
        return this.#renderToString(instance);
    }
};
VueEngine = __decorate([
    ViewEngine("vue", {
        requires: "vue"
    })
], VueEngine);
export { VueEngine };
//# sourceMappingURL=VueEngine.js.map