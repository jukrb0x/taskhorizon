import { createContext, PlatformApplication, PlatformBuilder, PlatformExceptions, PlatformHandlerType, runInContext } from "@tsed/common";
import { Env, isFunction } from "@tsed/core";
import Express from "express";
import { promisify } from "util";
import { staticsMiddleware } from "../middlewares/staticsMiddleware.js";
/**
 * @platform
 * @express
 */
export class PlatformExpress {
    injector;
    providers = [];
    #multer;
    constructor(injector) {
        this.injector = injector;
        import("multer").then(({ default: multer }) => (this.#multer = multer));
    }
    /**
     * Create new serverless application. In this mode, the component scan are disabled.
     * @param module
     * @param settings
     */
    static create(module, settings = {}) {
        return PlatformBuilder.create(module, {
            ...settings,
            adapter: PlatformExpress
        });
    }
    /**
     * Bootstrap a server application
     * @param module
     * @param settings
     */
    static async bootstrap(module, settings = {}) {
        return PlatformBuilder.bootstrap(module, {
            ...settings,
            adapter: PlatformExpress
        });
    }
    // onInit() {
    //   const middlewares = this.injector.settings.get("middlewares", []);
    //
    //   this.injector.settings.set(
    //     "middlewares"
    //     // middlewares.filter((middleware) => {
    //     //   const name = nameOf(middleware);
    //     //   if (["textParser", "jsonParser", "rawParser", "urlencodedParser"].includes(name)) {
    //     //     this.injector.settings.set(`express.bodyParser.${name.replace("Parser", "")}`, () => middleware);
    //     //     return false;
    //     //   }
    //     //
    //     //   return true;
    //     // })
    //   );
    // }
    async beforeLoadRoutes() {
        const injector = this.injector;
        const app = this.injector.get(PlatformApplication);
        // disable x-powered-by header
        injector.settings.get("env") === Env.PROD && app.getApp().disable("x-powered-by");
        await this.configureViewsEngine();
    }
    async afterLoadRoutes() {
        const app = this.injector.get(PlatformApplication);
        const platformExceptions = this.injector.get(PlatformExceptions);
        // NOT FOUND
        app.use((req, res, next) => {
            const { $ctx } = req;
            !$ctx.isDone() && platformExceptions?.resourceNotFound(req.$ctx);
        });
        // EXCEPTION FILTERS
        app.use((err, req, res, next) => {
            const { $ctx } = req;
            !$ctx.isDone() && platformExceptions?.catch(err, $ctx);
        });
    }
    mapLayers(layers) {
        const app = this.getPlatformApplication();
        const rawApp = app.getApp();
        layers.forEach((layer) => {
            switch (layer.method) {
                case "statics":
                    rawApp.use(layer.path, this.statics(layer.path, layer.opts));
                    return;
            }
            rawApp[layer.method](...layer.getArgs());
        });
    }
    mapHandler(handler, metadata) {
        switch (metadata.type) {
            case PlatformHandlerType.RAW_FN:
            case PlatformHandlerType.RAW_ERR_FN:
                return handler;
            case PlatformHandlerType.ERR_MIDDLEWARE:
                return async (error, req, res, next) => {
                    return runInContext(req.$ctx, () => {
                        const { $ctx } = req;
                        $ctx.next = next;
                        $ctx.error = error;
                        return handler($ctx);
                    });
                };
            default:
                return (req, res, next) => {
                    return runInContext(req.$ctx, () => {
                        req.$ctx.next = next;
                        handler(req.$ctx);
                    });
                };
        }
    }
    useContext() {
        const app = this.getPlatformApplication();
        const invoke = createContext(this.injector);
        this.injector.logger.debug("Mount app context");
        app.use(async (request, response, next) => {
            const $ctx = await invoke({ request, response });
            await $ctx.start();
            $ctx.response.getRes().on("finish", () => $ctx.finish());
            return runInContext($ctx, next);
        });
        return this;
    }
    app() {
        const app = this.injector.settings.get("express.app") || Express();
        return {
            app,
            callback: () => app
        };
    }
    multipart(options) {
        const m = this.#multer(options);
        const makePromise = (multer, name) => {
            // istanbul ignore next
            if (!multer[name])
                return;
            const fn = multer[name];
            multer[name] = function apply(...args) {
                const middleware = Reflect.apply(fn, this, args);
                return (req, res) => promisify(middleware)(req, res);
            };
        };
        makePromise(m, "any");
        makePromise(m, "array");
        makePromise(m, "fields");
        makePromise(m, "none");
        makePromise(m, "single");
        return m;
    }
    statics(endpoint, options) {
        const { root, ...props } = options;
        return staticsMiddleware(root, props);
    }
    bodyParser(type, additionalOptions = {}) {
        const opts = this.injector.settings.get(`express.bodyParser.${type}`);
        let parser = Express[type];
        let options = {};
        if (isFunction(opts)) {
            parser = opts;
            options = {};
        }
        if (type === "urlencoded") {
            options.extended = true;
        }
        options.verify = (req, _res, buffer) => {
            const rawBody = this.injector.settings.get(`rawBody`);
            if (rawBody) {
                req.rawBody = buffer;
            }
            return true;
        };
        return parser({ ...options, ...additionalOptions });
    }
    getPlatformApplication() {
        return this.injector.get(PlatformApplication);
    }
    async configureViewsEngine() {
        const injector = this.injector;
        const app = this.injector.get(PlatformApplication);
        try {
            const { exists, disabled } = this.injector.settings.get("views") || {};
            if (exists && !disabled) {
                const { PlatformViews } = await import("@tsed/platform-views");
                const platformViews = injector.get(PlatformViews);
                const express = app.getApp();
                platformViews.getEngines().forEach(({ extension, engine }) => {
                    express.engine(extension, engine.render);
                });
                platformViews.viewEngine && express.set("view engine", platformViews.viewEngine);
                platformViews.root && express.set("views", platformViews.root);
            }
        }
        catch (error) {
            // istanbul ignore next
            injector.logger.warn({
                event: "PLATFORM_VIEWS_ERROR",
                message: "Unable to configure the PlatformViews service on your environment.",
                error
            });
        }
    }
}
//# sourceMappingURL=PlatformExpress.js.map