import { isArray } from "./isArray.js";
import { isDate } from "./isDate.js";
import { isFunction } from "./isFunction.js";
import { isNil } from "./isNil.js";
import { isPrimitive } from "./isPrimitive.js";
import { isSymbol } from "./isSymbol.js";
import { isBuffer } from "./isBuffer.js";
import { isRegExp } from "./isRegExp.js";
const isBasicType = (source) => isNil(source) || isPrimitive(source) || isSymbol(source) || isFunction(source);
/**
 * Return a cloned value
 * @param source
 * @param stack
 */
export function deepClone(source, stack = new WeakMap()) {
    let dest;
    if (isBasicType(source)) {
        return source;
    }
    if (isBuffer(source)) {
        const copy = Buffer.alloc(source.length);
        source.copy(copy);
        return copy;
    }
    if (isDate(source)) {
        return new Date(source);
    }
    if (isRegExp(source)) {
        return new RegExp(source);
    }
    const stacked = stack.get(source);
    if (stacked) {
        // See issue #1619
        // istanbul ignore next
        process.env.TSED_TRACK_CIRCULAR_REF && console.trace("Circular ref detected on deepClone", stacked);
        return stacked;
    }
    if (isArray(source)) {
        dest = [];
    }
    else {
        dest = {};
        stack.set(source, dest);
    }
    for (const key in source) {
        // Use getOwnPropertyDescriptor instead of source[key] to prevent from triggering setter/getter.
        const descriptor = Object.getOwnPropertyDescriptor(source, key);
        if (descriptor) {
            if (!isFunction(descriptor.value)) {
                dest[key] = deepClone(descriptor.value, stack);
            }
            else {
                Object.defineProperty(dest, key, descriptor);
            }
        }
    }
    if (!isArray(source)) {
        const prototype = Reflect.getPrototypeOf(source);
        Reflect.setPrototypeOf(dest, prototype);
    }
    return dest;
}
//# sourceMappingURL=deepClone.js.map